--[[
    @Author: Zuka Tech
    @Date: 11/6/2025
    @Description: A modular, client-sided chat command system for Myself in Roblox.
                 This version includes a centralized command registry and a fully-featured
                 command bar with real-time auto-completion. --WIP
]]

-- ==========================================================
-- NEW: Animated Splash Screen Intro
-- ==========================================================
local function showSplashScreen()
    --// --- Services ---
    local CoreGui = game:GetService("CoreGui")
    local TweenService = game:GetService("TweenService")
    
    --// --- UI Creation ---
    local sg = Instance.new("ScreenGui")
    sg.Name = "ZukaSplashScreen"
    sg.ResetOnSpawn = false
    sg.Parent = CoreGui

    -- Main container that covers the screen
    local mainFrame = Instance.new("Frame", sg)
    mainFrame.Size = UDim2.fromScale(1, 1)
    mainFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 25)
    mainFrame.BackgroundTransparency = 1 -- Start fully transparent

    -- Main Title
    local title = Instance.new("TextLabel", mainFrame)
    title.Size = UDim2.new(0, 500, 0, 50)
    title.Position = UDim2.new(0.5, -250, 0.5, -60)
    title.BackgroundTransparency = 1
    title.Font = Enum.Font.Code
    title.Text = "" -- Will be animated
    title.TextColor3 = Color3.fromRGB(200, 220, 255)
    title.TextSize = 38

    -- Subtitle / Status
    local subtitle = Instance.new("TextLabel", mainFrame)
    subtitle.Size = UDim2.new(0, 500, 0, 20)
    subtitle.Position = UDim2.new(0.5, -250, 0.5, -15)
    subtitle.BackgroundTransparency = 1
    subtitle.Font = Enum.Font.Code
    subtitle.Text = "" -- Will be animated
    subtitle.TextColor3 = Color3.fromRGB(120, 140, 180)
    subtitle.TextSize = 16
    subtitle.TextXAlignment = Enum.TextXAlignment.Left

    -- Loading Bar Background
    local loadingBarBG = Instance.new("Frame", mainFrame)
    loadingBarBG.Size = UDim2.new(0, 300, 0, 8)
    loadingBarBG.Position = UDim2.new(0.5, -150, 0.5, 20)
    loadingBarBG.BackgroundColor3 = Color3.fromRGB(40, 40, 60)
    loadingBarBG.BorderSizePixel = 0
    Instance.new("UICorner", loadingBarBG).CornerRadius = UDim.new(1, 0)

    -- Loading Bar Fill (this part animates)
    local loadingBarFill = Instance.new("Frame", loadingBarBG)
    loadingBarFill.Size = UDim2.new(0, 0, 1, 0) -- Starts at zero width
    loadingBarFill.BackgroundColor3 = Color3.fromRGB(80, 130, 255)
    loadingBarFill.BorderSizePixel = 0
    Instance.new("UICorner", loadingBarFill).CornerRadius = UDim.new(1, 0)

    --// --- Animation Sequence ---
    task.spawn(function()
        -- 1. Fade in the background
        for i = 1, 0, -0.05 do
            mainFrame.BackgroundTransparency = i
            task.wait()
        end
        mainFrame.BackgroundTransparency = 0

        -- 2. Animate Title
        local titleText = "Zuka's Admin"
        for i = 1, #titleText do
            title.Text = string.sub(titleText, 1, i)
            task.wait(0.04)
        end

        -- 3. Animate Subtitle
        local subtitleText = "Initializing Modules..."
        for i = 1, #subtitleText do
            subtitle.Text = string.sub(subtitleText, 1, i)
            task.wait(0.02)
        end
        
        -- 4. Animate Loading Bar
        local tweenInfo = TweenInfo.new(1.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
        local goal = { Size = UDim2.new(1, 0, 1, 0) }
        local tween = TweenService:Create(loadingBarFill, tweenInfo, goal)
        tween:Play()
        tween.Completed:Wait() -- Wait for the bar to finish filling

        task.wait(0.5) -- A brief pause before fading out

        -- 5. Fade out the entire screen
        for i = 0, 1, 0.05 do
            mainFrame.BackgroundTransparency = i
            task.wait()
        end

        -- 6. Clean up the UI
        sg:Destroy()
    end)
    
    -- This allows the rest of the script to continue loading while the animation plays.
    -- We wait a fixed time for the animation to finish before allowing full execution.
    task.wait(4.5) 
end

-- Run the splash screen at the start of the script
showSplashScreen()

-- ==========================================================
-- Services & Setup
-- ==========================================================
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")
local LocalPlayer = Players.LocalPlayer

-- Executor/Environment Dependencies
local function DoNotif(message, duration) print("NOTIFICATION: " .. tostring(message) .. " (for " .. tostring(duration) .. "s)") end
local function NaProtectUI(gui) if gui then gui.Parent = CoreGui or LocalPlayer:WaitForChild("PlayerGui") end; print("UI Protection applied to: " .. gui.Name) end
if not setclipboard then setclipboard = function(text) print("Clipboard (fallback): " .. text); DoNotif("setclipboard is not available. See console for output.", 5) end end

-- ==========================================================
-- Configuration
-- ==========================================================
local Prefix = ";"
local Commands = {}
local CommandInfo = {} -- For ;cmds UI, now populated by RegisterCommand
local Modules = {}

-- ==========================================================
-- NEW: Centralized Command Registration Function
-- ==========================================================
function RegisterCommand(info, func)
    if not info or not info.Name or not func then
        warn("Command registration failed: Missing info, name, or function.")
        return
    end

    local name = info.Name:lower()

    -- Ensure no duplicate commands or aliases are registered
    if Commands[name] then
        warn("Command registration skipped: Command '" .. name .. "' already exists.")
        return
    end

    -- 1. Add to the command execution table
    Commands[name] = func

    -- 2. Add aliases to the execution table
    if info.Aliases then
        for _, alias in ipairs(info.Aliases) do
            local aliasLower = alias:lower()
            if Commands[aliasLower] then
                warn("Alias '" .. aliasLower .. "' for command '" .. name .. "' conflicts with an existing command and was not registered.")
            else
                Commands[aliasLower] = func
            end
        end
    end

    -- 3. Add the detailed info to the list for the ;cmds UI
    table.insert(CommandInfo, info)
end

-- ==========================================================
-- NEW: Auto-Complete Module
-- ==========================================================
Modules.AutoComplete = {}; function Modules.AutoComplete:GetMatches(prefix)
    local matches = {}
    if typeof(prefix) ~= "string" or #prefix == 0 then return matches end
    prefix = prefix:lower()

    for cmdName, _ in pairs(Commands) do
        if cmdName:sub(1, #prefix) == prefix then
            table.insert(matches, cmdName)
        end
    end
    table.sort(matches) -- Keep the list clean and alphabetical
    return matches
end

-- ==========================================================
-- OVERHAULED: CommandBar Module with Auto-Completion
-- ==========================================================

--// --- Module Definition ---
Modules.CommandBar = {
    State = {
        UI = nil,
        KeybindConnection = nil
    }
}

function Modules.CommandBar:Toggle()
    --// --- Disabling Logic (No changes needed) ---
    if self.State.UI then
        self.State.UI:Destroy()
        self.State.UI = nil
        if self.State.KeybindConnection then
            self.State.KeybindConnection:Disconnect()
            self.State.KeybindConnection = nil
        end
        return
    end

    --// --- Services for UI ---
    local TweenService = game:GetService("TweenService")
    local UserInputService = game:GetService("UserInputService")

    --// --- UI Creation (With Transparency and Layout Fix) ---

    local ui = Instance.new("ScreenGui"); ui.Name = "CommandBarUI"; NaProtectUI(ui); self.State.UI = ui
    local container = Instance.new("Frame", ui)
    container.Size = UDim2.new(0, 450, 0, 32)
    container.Position = UDim2.new(0.5, -225, 0, 10)
    container.BackgroundTransparency = 1

    -- Main Bar Frame
    local bar = Instance.new("Frame", container)
    bar.Size = UDim2.new(1, 0, 1, 0)
    bar.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
    bar.BackgroundTransparency = 0.3 -- Increased transparency

    Instance.new("UICorner", bar).CornerRadius = UDim.new(0, 6)
    local barStroke = Instance.new("UIStroke", bar)
    barStroke.Color = Color3.fromRGB(80, 80, 100)
    barStroke.Thickness = 1
    local barGradient = Instance.new("UIGradient", bar)
    barGradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(55, 55, 70)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(25, 25, 35))
    })
    barGradient.Rotation = 90

    -- Prefix Tag
    local prefixLabel = Instance.new("TextLabel", bar)
    prefixLabel.Size = UDim2.new(0, 30, 0, 20)
    prefixLabel.Position = UDim2.new(0, 6, 0.5, -10)
    prefixLabel.BackgroundColor3 = Color3.fromRGB(80, 100, 255)
    prefixLabel.Font = Enum.Font.GothamSemibold
    prefixLabel.Text = Prefix
    prefixLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    prefixLabel.TextSize = 16
    Instance.new("UICorner", prefixLabel).CornerRadius = UDim.new(0, 4)

    -- Text Box
    local textBox = Instance.new("TextBox", bar)
    textBox.Size = UDim2.new(1, -42, 1, 0)
    textBox.Position = UDim2.fromOffset(38, 0)
    textBox.BackgroundTransparency = 1
    textBox.Font = Enum.Font.Gotham
    textBox.PlaceholderText = "Enter command..."
    textBox.PlaceholderColor3 = Color3.fromRGB(120, 120, 140)
    textBox.TextColor3 = Color3.fromRGB(255, 255, 255)
    textBox.TextSize = 16
    textBox.ClearTextOnFocus = false

    -- Suggestions Frame
    local suggestionsFrame = Instance.new("ScrollingFrame", container)
    suggestionsFrame.Size = UDim2.new(1, 0, 0, 120)
    suggestionsFrame.Position = UDim2.new(0, 0, 1, 4)
    suggestionsFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
    suggestionsFrame.BackgroundTransparency = 0.25 -- Increased transparency
    suggestionsFrame.BorderSizePixel = 0
    suggestionsFrame.ScrollBarThickness = 5
    suggestionsFrame.Visible = false
    Instance.new("UICorner", suggestionsFrame).CornerRadius = UDim.new(0, 6)
    Instance.new("UIStroke", suggestionsFrame).Color = barStroke.Color

    --// --- THE FIX for overlapping ---
    local listLayout = Instance.new("UIListLayout", suggestionsFrame)
    listLayout.Padding = UDim.new(0, 3)
    listLayout.SortOrder = Enum.SortOrder.LayoutOrder
    -- This connection automatically updates the scrollable area size whenever
    -- a new suggestion is added or removed, fixing the overlap issue.
    listLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        suggestionsFrame.CanvasSize = UDim2.new(0, 0, 0, listLayout.AbsoluteContentSize.Y)
    end)
    --// --- END OF FIX ---

    --// --- Core Logic (Auto-completion, Drag, Keybind) ---
    local isScriptUpdatingText = false
    local MAX_SUGGESTIONS = 5

    local function clearSuggestions()
        suggestionsFrame.Visible = false
        for _, child in ipairs(suggestionsFrame:GetChildren()) do
            if child:IsA("TextButton") then
                child:Destroy()
            end
        end
    end
    
    local function createSuggestionButton(text)
        local button = Instance.new("TextButton")
        button.Text = "  " .. text
        button.TextSize = 14
        button.Font = Enum.Font.Gotham
        button.TextColor3 = Color3.fromRGB(210, 210, 220)
        button.TextXAlignment = Enum.TextXAlignment.Left
        button.BackgroundTransparency = 1
        button.Size = UDim2.new(1, 0, 0, 24)
        button.Parent = suggestionsFrame
        Instance.new("UICorner", button).CornerRadius = UDim.new(0, 4)

        local tweenInfo = TweenInfo.new(0.15)
        button.MouseEnter:Connect(function() TweenService:Create(button, tweenInfo, {BackgroundTransparency = 0.8, BackgroundColor3 = Color3.fromRGB(255,255,255)}):Play() end)
        button.MouseLeave:Connect(function() TweenService:Create(button, tweenInfo, {BackgroundTransparency = 1}):Play() end)
        
        button.MouseButton1Click:Connect(function()
            isScriptUpdatingText = true
            textBox.Text = text .. " "
            textBox:CaptureFocus()
            isScriptUpdatingText = false
            clearSuggestions()
        end)
    end

    local function updateSuggestions() if isScriptUpdatingText then return end; clearSuggestions(); local inputText=textBox.Text:match("^%s*(%S*)"); if not inputText or #inputText==0 then return end; local matches=Modules.AutoComplete:GetMatches(inputText); if #matches > 0 then suggestionsFrame.Visible=true; for i, match in ipairs(matches) do if i > MAX_SUGGESTIONS then break end; createSuggestionButton(match) end end end
    textBox.Changed:Connect(function(prop) if prop == "Text" then updateSuggestions() end end)
    textBox.FocusLost:Connect(function(enterPressed) if enterPressed and textBox.Text:len()>0 then processCommand(Prefix..textBox.Text); textBox.Text="" end; task.wait(0.1); clearSuggestions() end)
    textBox.Focused:Connect(updateSuggestions)
    
    local function drag(o) local d,s,p; o.InputBegan:Connect(function(i) if i.UserInputType==Enum.UserInputType.MouseButton1 then d,s,p=true,i.Position,o.Position;i.Changed:Connect(function()if i.UserInputState==Enum.UserInputState.End then d=false end end)end end); o.InputChanged:Connect(function(i) if i.UserInputType==Enum.UserInputType.MouseMovement and d then o.Position=UDim2.new(p.X.Scale,p.X.Offset+i.Position.X-s.X,p.Y.Scale,p.Y.Offset+i.Position.Y-s.Y)end end)end
    drag(container)

    self.State.KeybindConnection = UserInputService.InputBegan:Connect(function(input, gpe) if gpe then return end; if input.KeyCode == Enum.KeyCode.Semicolon then textBox:CaptureFocus() end end)
    
    DoNotif("Command bar enabled.", 3)
end

-- ==========================================================
-- Core Modules (Unchanged)
-- ==========================================================
Modules.Fly = {
    State = {
        IsActive = false,
        Speed = 60, -- Reduced speed as requested
        SprintMultiplier = 2.5,
        Connections = {},
        BodyMovers = {} -- Will now store Attachments and Constraints
    }
}

function Modules.Fly:SetSpeed(s)
    local n = tonumber(s)
    if n and n > 0 then
        self.State.Speed = n
        DoNotif("Fly speed set to: " .. n, 3)
    else
        DoNotif("Invalid speed.", 3)
    end
end

function Modules.Fly:Disable()
    if not self.State.IsActive then return end
    self.State.IsActive = false

    local h = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    if h then h.PlatformStand = false end

    -- Destroy all created movers and attachments
    for _, mover in pairs(self.State.BodyMovers) do
        if mover and mover.Parent then
            mover:Destroy()
        end
    end

    -- Disconnect all event listeners
    for _, connection in ipairs(self.State.Connections) do
        connection:Disconnect()
    end

    table.clear(self.State.BodyMovers)
    table.clear(self.State.Connections)
    DoNotif("Fly disabled.", 3)
end

function Modules.Fly:Enable()
    if self.State.IsActive then return end
    local char = LocalPlayer.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    local humanoid = char and char:FindFirstChildOfClass("Humanoid")
    if not (hrp and humanoid) then
        DoNotif("Character required.", 3)
        return
    end

    self.State.IsActive = true
    DoNotif("Fly Enabled.", 3)
    humanoid.PlatformStand = true

    --// --- NEW: Modern Mover Setup ---
    -- Constraints need attachments to work. We create one on the character and one in the world.
    local hrpAttachment = Instance.new("Attachment", hrp)
    local worldAttachment = Instance.new("Attachment", workspace.Terrain)
    worldAttachment.WorldCFrame = hrp.CFrame -- Align it to the character's start position

    -- AlignOrientation replaces BodyGyro. It's smoother and more stable.
    local alignOrientation = Instance.new("AlignOrientation")
    alignOrientation.Mode = Enum.OrientationAlignmentMode.OneAttachment
    alignOrientation.Attachment0 = hrpAttachment
    alignOrientation.Responsiveness = 200 -- High value for snappy camera following
    alignOrientation.MaxTorque = math.huge
    alignOrientation.Parent = hrp

    -- LinearVelocity replaces BodyVelocity. It's more stable for consistent movement.
    local linearVelocity = Instance.new("LinearVelocity")
    linearVelocity.Attachment0 = hrpAttachment
    linearVelocity.RelativeTo = Enum.ActuatorRelativeTo.World
    linearVelocity.MaxForce = math.huge
    linearVelocity.VectorVelocity = Vector3.zero
    linearVelocity.Parent = hrp

    -- Store all created objects for cleanup
    self.State.BodyMovers.HRPAttachment = hrpAttachment
    self.State.BodyMovers.WorldAttachment = worldAttachment
    self.State.BodyMovers.AlignOrientation = alignOrientation
    self.State.BodyMovers.LinearVelocity = linearVelocity

    --// --- Input Handling (No changes needed, this part was good) ---
    local keys = {}
    local function onInput(input, gameProcessed)
        if not gameProcessed then
            keys[input.KeyCode] = (input.UserInputState == Enum.UserInputState.Begin)
        end
    end
    table.insert(self.State.Connections, UserInputService.InputBegan:Connect(onInput))
    table.insert(self.State.Connections, UserInputService.InputEnded:Connect(onInput))

    --// --- Main Loop (Updated to control the new movers) ---
    local loop = RunService.RenderStepped:Connect(function()
        if not self.State.IsActive or not hrp.Parent then return end

        local camera = workspace.CurrentCamera
        alignOrientation.CFrame = camera.CFrame -- Make the character face where the camera is looking

        local direction = Vector3.new()
        if keys[Enum.KeyCode.W] then direction += camera.CFrame.LookVector end
        if keys[Enum.KeyCode.S] then direction -= camera.CFrame.LookVector end
        if keys[Enum.KeyCode.D] then direction += camera.CFrame.RightVector end
        if keys[Enum.KeyCode.A] then direction -= camera.CFrame.RightVector end
        if keys[Enum.KeyCode.Space] or keys[Enum.KeyCode.E] then direction += Vector3.yAxis end
        if keys[Enum.KeyCode.LeftControl] or keys[Enum.KeyCode.Q] then direction -= Vector3.yAxis end

        local speed = keys[Enum.KeyCode.LeftShift] and self.State.Speed * self.State.SprintMultiplier or self.State.Speed
        
        -- Apply the calculated velocity to the new mover
        linearVelocity.VectorVelocity = direction.Magnitude > 0 and direction.Unit * speed or Vector3.zero
    end)
    table.insert(self.State.Connections, loop)
end

function Modules.Fly:Toggle()
    if self.State.IsActive then
        self:Disable()
    else
        self:Enable()
    end
end

Modules.Noclip = { State = { IsActive = false, Connection = nil } }; function Modules.Noclip:Enable() if self.State.IsActive then return end; self.State.IsActive = true; self.State.Connection = RunService.Stepped:Connect(function() if LocalPlayer.Character then for _, p in ipairs(LocalPlayer.Character:GetDescendants()) do if p:IsA("BasePart") then p.CanCollide = false end end end end); DoNotif("Noclip enabled.", 3) end; function Modules.Noclip:Disable() if not self.State.IsActive then return end; self.State.IsActive = false; if self.State.Connection then self.State.Connection:Disconnect(); self.State.Connection = nil end; DoNotif("Noclip disabled.", 3) end; function Modules.Noclip:Toggle() if self.State.IsActive then self:Disable() else self:Enable() end end

-- ==========================================================
-- WallWalk Module (Patched and Architecturally Sound)
-- ==========================================================
local DEFAULT_GRAVITY = Vector3.new(0, -196.2, 0)
local RAY_DISTANCE = 15 -- How far to check for a wall.

Modules.WallWalk = { State = { IsActive = false, Connection = nil } };

function Modules.WallWalk:Enable()
    if self.State.IsActive then return end
    self.State.IsActive = true

    if not (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")) then
        DoNotif("Character required for WallWalk.", 3)
        self.State.IsActive = false
        return
    end

    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = {LocalPlayer.Character}

    self.State.Connection = RunService.RenderStepped:Connect(function()
        local character = LocalPlayer.Character
        local hrp = character and character:FindFirstChild("HumanoidRootPart")
        local camera = Workspace.CurrentCamera

        -- Stop if the module is disabled or if the character/camera is invalid
        if not (self.State.IsActive and hrp and camera) then
            if Workspace.Gravity ~= DEFAULT_GRAVITY then Workspace.Gravity = DEFAULT_GRAVITY end
            return
        end

        -- Cast a ray from the character in the direction the camera is facing
        local origin = hrp.Position
        local direction = camera.CFrame.LookVector * RAY_DISTANCE
        local result = Workspace:Raycast(origin, direction, raycastParams)

        -- If the ray hits a collidable surface, adjust gravity towards it
        if result and result.Instance and result.Instance.CanCollide then
            Workspace.Gravity = -result.Normal * 196.2
        else
            -- CRITICAL FIX: If not looking at a surface, reset gravity to normal
            Workspace.Gravity = DEFAULT_GRAVITY
        end
    end)
    DoNotif("WallWalk enabled.", 3)
end

function Modules.WallWalk:Disable()
    if not self.State.IsActive then return end
    self.State.IsActive = false
    if self.State.Connection then
        self.State.Connection:Disconnect()
        self.State.Connection = nil
    end
    -- Always ensure gravity is reset when disabled
    workspace.Gravity = DEFAULT_GRAVITY
    DoNotif("WallWalk disabled.", 3)
end

function Modules.WallWalk:Toggle()
    if self.State.IsActive then self:Disable() else self:Enable() end
end

Modules.CommandsUI = { State = { UI = nil } }

function Modules.CommandsUI:Toggle()
    if self.State.UI then self.State.UI:Destroy(); self.State.UI = nil; return end

    --// --- Services ---
    local TweenService = game:GetService("TweenService")

    --// --- UI Creation ---
    local ui = Instance.new("ScreenGui"); ui.Name = "CommandsUI"; NaProtectUI(ui); self.State.UI = ui
    local mainFrame = Instance.new("Frame", ui)
    mainFrame.Size = UDim2.fromOffset(500, 350); mainFrame.Position = UDim2.new(0.5, -250, 0.5, -175)
    mainFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 35); mainFrame.BackgroundTransparency = 0.15
    Instance.new("UICorner", mainFrame).CornerRadius = UDim.new(0, 8)
    Instance.new("UIStroke", mainFrame).Color = Color3.fromRGB(80, 80, 100)
    
    local header = Instance.new("Frame", mainFrame)
    header.Size = UDim2.new(1, 0, 0, 32); header.BackgroundTransparency = 1
    local headerGradient = Instance.new("UIGradient", header)
    headerGradient.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, Color3.fromRGB(55,55,70)), ColorSequenceKeypoint.new(1, Color3.fromRGB(25,25,35))}); headerGradient.Rotation = 90
    local title = Instance.new("TextLabel", header)
    title.Size = UDim2.new(1, -30, 1, 0); title.Position = UDim2.fromOffset(10, 0)
    title.BackgroundTransparency = 1; title.Font = Enum.Font.GothamSemibold; title.Text = "Command List"
    title.TextColor3 = Color3.fromRGB(220, 220, 255); title.TextXAlignment = Enum.TextXAlignment.Left; title.TextSize = 16
    local closeButton = Instance.new("TextButton", header)
    closeButton.Size = UDim2.fromOffset(32, 32); closeButton.Position = UDim2.new(1, -32, 0, 0)
    closeButton.BackgroundTransparency = 1; closeButton.Font = Enum.Font.Code; closeButton.Text = "X"
    closeButton.TextColor3 = Color3.fromRGB(200, 200, 220); closeButton.TextSize = 24
    closeButton.MouseButton1Click:Connect(function() self:Toggle() end)

    -- Search Bar
    local searchBox = Instance.new("TextBox", mainFrame)
    searchBox.Size = UDim2.new(1, -20, 0, 28); searchBox.Position = UDim2.new(0, 10, 0, 40)
    searchBox.BackgroundColor3 = Color3.fromRGB(20, 20, 30); searchBox.Font = Enum.Font.Gotham
    searchBox.Text = "" -- <<<<<<<<<<<<<<<<<<<<<<<< THE FIX IS HERE
    searchBox.PlaceholderText = "Search commands..."; searchBox.PlaceholderColor3 = Color3.fromRGB(120, 120, 140)
    searchBox.TextColor3 = Color3.fromRGB(255, 255, 255); searchBox.TextSize = 14
    searchBox.ClearTextOnFocus = false
    Instance.new("UICorner", searchBox).CornerRadius = UDim.new(0, 5)
    Instance.new("UIStroke", searchBox).Color = Color3.fromRGB(60, 60, 80)

    -- Scrolling Frame and the rest of the UI...
    local scrollingFrame = Instance.new("ScrollingFrame", mainFrame)
    scrollingFrame.Size = UDim2.new(1, -20, 1, -80); scrollingFrame.Position = UDim2.fromOffset(10, 75)
    scrollingFrame.BackgroundTransparency = 1; scrollingFrame.BorderSizePixel = 0; scrollingFrame.ScrollBarThickness = 6
    local listLayout = Instance.new("UIListLayout", scrollingFrame)
    listLayout.Padding = UDim.new(0, 5); listLayout.SortOrder = Enum.SortOrder.LayoutOrder
    listLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function() scrollingFrame.CanvasSize = UDim2.new(0, 0, 0, listLayout.AbsoluteContentSize.Y) end)

    -- [ The rest of your functional code for this module remains exactly the same ]
    local function createCommandEntry(info) local entryButton=Instance.new("TextButton"); entryButton.Name=info.Name; entryButton.AutomaticSize=Enum.AutomaticSize.Y; entryButton.Size=UDim2.new(1,0,0,40); entryButton.BackgroundColor3=Color3.fromRGB(40,40,55); entryButton.BackgroundTransparency=1; entryButton.Parent=scrollingFrame; Instance.new("UICorner",entryButton).CornerRadius=UDim.new(0,5); local nameLabel=Instance.new("TextLabel",entryButton); nameLabel.Size=UDim2.new(1,-10,0,18); nameLabel.Position=UDim2.fromOffset(5,4); nameLabel.BackgroundTransparency=1; nameLabel.Font=Enum.Font.GothamBold; nameLabel.Text=Prefix..info.Name; nameLabel.TextColor3=Color3.fromRGB(80,150,255); nameLabel.TextXAlignment=Enum.TextXAlignment.Left; nameLabel.TextSize=16; local aliasText=#info.Aliases>0 and "Aliases: "..table.concat(info.Aliases,", ") or ""; local aliasLabel=Instance.new("TextLabel",entryButton); aliasLabel.Size=UDim2.new(1,-10,0,14); aliasLabel.Position=UDim2.fromOffset(5,22); aliasLabel.BackgroundTransparency=1; aliasLabel.Font=Enum.Font.Gotham; aliasLabel.Text=aliasText; aliasLabel.TextColor3=Color3.fromRGB(150,160,180); aliasLabel.TextXAlignment=Enum.TextXAlignment.Left; aliasLabel.TextSize=12; local descLabel=Instance.new("TextLabel",entryButton); descLabel.Size=UDim2.new(1,-10,0,30); descLabel.Position=UDim2.fromOffset(5,38); descLabel.BackgroundTransparency=1; descLabel.Font=Enum.Font.Gotham; descLabel.Text=info.Description or ""; descLabel.TextColor3=Color3.fromRGB(210,210,220); descLabel.TextXAlignment=Enum.TextXAlignment.Left; descLabel.TextSize=14; descLabel.TextWrapped=true; descLabel.AutomaticSize=Enum.AutomaticSize.Y; local tweenInfo=TweenInfo.new(0.15); entryButton.MouseEnter:Connect(function() TweenService:Create(entryButton,tweenInfo,{BackgroundTransparency=0.8}):Play() end); entryButton.MouseLeave:Connect(function() TweenService:Create(entryButton,tweenInfo,{BackgroundTransparency=1}):Play() end); entryButton.MouseButton1Click:Connect(function() local commandBarUI=Modules.CommandBar and Modules.CommandBar.State.UI; if commandBarUI then local textBox=commandBarUI:FindFirstChild("Frame",true):FindFirstChild("TextBox",true); if textBox then textBox.Text=info.Name.." "; textBox:CaptureFocus() end end; self:Toggle() end); return entryButton end
    local allEntries = {}; for _, info in ipairs(CommandInfo) do table.insert(allEntries, createCommandEntry(info)) end
    searchBox.Changed:Connect(function() local searchText=searchBox.Text:lower(); for _, entry in ipairs(allEntries) do local info=CommandInfo[tonumber(entry.Name)] or {}; local nameMatch=entry.Name:lower():find(searchText,1,true); local aliasMatch=table.concat(info.Aliases or {}):lower():find(searchText,1,true); local descMatch=(info.Description or ""):lower():find(searchText,1,true); entry.Visible=(searchText=="") or nameMatch or aliasMatch or descMatch end end)
    local function drag(o) local d,s,p; o.InputBegan:Connect(function(i) if i.UserInputType==Enum.UserInputType.MouseButton1 then d,s,p=true,i.Position,o.Position;i.Changed:Connect(function()if i.UserInputState==Enum.UserInputState.End then d=false end end)end end); o.InputChanged:Connect(function(i) if i.UserInputType==Enum.UserInputType.MouseMovement and d then o.Position=UDim2.new(p.X.Scale,p.X.Offset+i.Position.X-s.X,p.Y.Scale,p.Y.Offset+i.Position.Y-s.Y)end end)end; drag(mainFrame)
end


Modules.ClickFling = {
    State = {
        IsActive = false,
        Connection = nil,
        UI = nil
    }
}

--// --- Services ---
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

--// --- Disable Function (No changes needed) ---
function Modules.ClickFling:Disable()
    self.State.IsActive = false
    if self.State.UI then
        self.State.UI:Destroy()
    end
    if self.State.Connection then
        self.State.Connection:Disconnect()
    end
    self.State.UI, self.State.Connection = nil, nil
    -- DoNotif("ClickFling Disabled.", 3)
end

--// --- Enable Function (With Corrected Raycasting) ---
function Modules.ClickFling:Enable()
    self:Disable()
    self.State.IsActive = true

    --// --- UI and Draggable Logic (No changes needed) ---
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "ClickFlingUI"
    screenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    self.State.UI = screenGui
    -- NaProtectUI(screenGui)

    local toggleButton = Instance.new("TextButton", screenGui)
    toggleButton.Size = UDim2.fromOffset(120, 40)
    toggleButton.Text = "ClickFling: ON"
    toggleButton.Position = UDim2.new(0.5, -60, 0, 10)
    toggleButton.TextColor3 = Color3.new(1, 1, 1);
    toggleButton.Font = Enum.Font.GothamBold;
    toggleButton.BackgroundColor3 = Color3.fromRGB(40, 40, 40);
    Instance.new("UICorner", toggleButton).CornerRadius = UDim.new(0, 8);

    toggleButton.MouseButton1Click:Connect(function()
        self.State.IsActive = not self.State.IsActive
        toggleButton.Text = "ClickFling: " .. (self.State.IsActive and "ON" or "OFF")
    end)

    local function makeDraggable(uiObject)
        local isDragging = false; local dragStart, startPosition;
        uiObject.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                isDragging = true; dragStart = input.Position; startPosition = uiObject.Position
                input.Changed:Connect(function() if input.UserInputState == Enum.UserInputState.End then isDragging = false end end)
            end
        end)
        uiObject.InputChanged:Connect(function(input)
            if (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) and isDragging then
                local delta = input.Position - dragStart; uiObject.Position = UDim2.new(startPosition.X.Scale, startPosition.X.Offset + delta.X, startPosition.Y.Scale, startPosition.Y.Offset + delta.Y)
            end
        end)
    end
    makeDraggable(toggleButton)

    --// --- Core Fling Logic (With Corrected Target Detection) ---
    self.State.Connection = UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
        if not self.State.IsActive or gameProcessedEvent or input.UserInputType ~= Enum.UserInputType.MouseButton1 then
            return
        end

        --// --- THIS IS THE FIX ---
        -- Create a proper RaycastParams object.
        local raycastParams = RaycastParams.new()
        raycastParams.FilterType = Enum.RaycastFilterType.Exclude
        -- Add your character and the UI to the filter to prevent clicking on them.
        raycastParams.FilterDescendantsInstances = {LocalPlayer.Character, screenGui}

        -- Use the camera to create a ray from your mouse position.
        local mouseRay = Workspace.CurrentCamera:ScreenPointToRay(input.Position.X, input.Position.Y)
        
        -- Perform the raycast with the CORRECT parameters.
        local raycastResult = Workspace:Raycast(mouseRay.Origin, mouseRay.Direction * 1000, raycastParams)
        --// --- END OF FIX ---

        local targetPlayer = raycastResult and Players:GetPlayerFromCharacter(raycastResult.Instance:FindFirstAncestorOfClass("Model"))
        if not targetPlayer or targetPlayer == LocalPlayer then return end

        local localChar = LocalPlayer.Character
        local localHRP = localChar and localChar:FindFirstChild("HumanoidRootPart")
        local targetHRP = targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not (localHRP and targetHRP) then return end

        -- DoNotif("Flinging " .. targetPlayer.Name, 2)

        local originalCFrame = localHRP.CFrame
        local originalFallenPartsHeight = Workspace.FallenPartsDestroyHeight
        Workspace.FallenPartsDestroyHeight = math.huge

        for i = 1, 7 do
            localHRP.CFrame = targetHRP.CFrame
            RunService.Heartbeat:Wait()
        end
        
        localHRP.Anchored = true
        RunService.Heartbeat:Wait()
        
        localHRP.CFrame = originalCFrame
        Workspace.FallenPartsDestroyHeight = originalFallenPartsHeight
        localHRP.Anchored = false
    end)

    -- DoNotif("ClickFling Enabled.", 5)
end

Modules.Reach = { State = { UI = nil } }; function Modules.Reach:_getTool() return (LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")) or (LocalPlayer:FindFirstChildOfClass("Backpack") and LocalPlayer.Backpack:FindFirstChildOfClass("Tool")) end; function Modules.Reach:Apply(reachType, size) if self.State.UI then self.State.UI:Destroy() end; local tool = self:_getTool(); if not tool then return DoNotif("No tool equipped.", 3) end; local parts = {}; for _, p in ipairs(tool:GetDescendants()) do if p:IsA("BasePart") then table.insert(parts, p) end end; if #parts == 0 then return DoNotif("Tool has no parts.", 3) end; local ui = Instance.new("ScreenGui"); ui.Name = "ReachPartSelector"; NaProtectUI(ui); self.State.UI = ui; local frame = Instance.new("Frame", ui); frame.Size = UDim2.fromOffset(250, 200); frame.Position = UDim2.new(0.5, -125, 0.5, -100); frame.BackgroundColor3 = Color3.fromRGB(35, 35, 45); Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 8); local title = Instance.new("TextLabel", frame); title.Size = UDim2.new(1, 0, 0, 30); title.BackgroundTransparency = 1; title.Font = Enum.Font.Code; title.Text = "Select a Part"; title.TextColor3 = Color3.fromRGB(200, 220, 255); title.TextSize = 16; local scroll = Instance.new("ScrollingFrame", frame); scroll.Size = UDim2.new(1, -20, 1, -40); scroll.Position = UDim2.fromOffset(10, 35); scroll.BackgroundColor3 = frame.BackgroundColor3; scroll.BorderSizePixel = 0; scroll.ScrollBarThickness = 6; local layout = Instance.new("UIListLayout", scroll); layout.Padding = UDim.new(0, 5); for _, part in ipairs(parts) do local btn = Instance.new("TextButton", scroll); btn.Size = UDim2.new(1, 0, 0, 30); btn.BackgroundColor3 = Color3.fromRGB(50, 50, 65); btn.TextColor3 = Color3.fromRGB(220, 220, 230); btn.Font = Enum.Font.Code; btn.Text = part.Name; btn.TextSize = 14; Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 4); btn.MouseButton1Click:Connect(function() if not part.Parent then ui:Destroy(); return DoNotif("Part gone.", 3) end; if not part:FindFirstChild("OGSize3") then local v = Instance.new("Vector3Value", part); v.Name = "OGSize3"; v.Value = part.Size end; if part:FindFirstChild("FunTIMES") then part.FunTIMES:Destroy() end; local sb = Instance.new("SelectionBox", part); sb.Adornee = part; sb.Name = "FunTIMES"; sb.LineThickness = 0.02; sb.Color3 = reachType == "box" and Color3.fromRGB(0,100,255) or Color3.fromRGB(255,0,0); if reachType == "box" then part.Size = Vector3.one * size else part.Size = Vector3.new(part.Size.X, part.Size.Y, size) end; part.Massless = true; ui:Destroy(); self.State.UI = nil; DoNotif("Applied reach.", 3) end) end end; function Modules.Reach:Reset() local tool = self:_getTool(); if not tool then return DoNotif("No tool to reset.", 3) end; for _, p in ipairs(tool:GetDescendants()) do if p:IsA("BasePart") then if p:FindFirstChild("OGSize3") then p.Size = p.OGSize3.Value; p.OGSize3:Destroy() end; if p:FindFirstChild("FunTIMES") then p.FUNTIMES:Destroy() end end end; DoNotif("Tool reach reset.", 3) end

--==========================================================
-- NEW: ModelReach Module
--==========================================================

Modules.ModelReach = {
    State = {
        ActiveUIs = {} -- Store UI on a per-model basis
    }
}

-- Private function to find a model in the workspace
function Modules.ModelReach:_findModel(modelName)
    if not modelName or modelName == "" then return nil end
    local inputName = modelName:lower()
    local exactMatch = nil
    local partialMatch = nil

    for _, child in ipairs(workspace:GetChildren()) do
        if child:IsA("Model") then
            local modelLowerName = child.Name:lower()
            if modelLowerName == inputName then
                exactMatch = child
                break
            end
            if not partialMatch and modelLowerName:sub(1, #inputName) == inputName then
                partialMatch = child
            end
        end
    end
    return exactMatch or partialMatch
end

-- Private function to get a tool from a model
function Modules.ModelReach:_getToolFromModel(model)
    if not model then return nil end
    return model:FindFirstChildOfClass("Tool")
end

-- Main function to apply reach to a part of a tool in a model
function Modules.ModelReach:Apply(modelName, reachType, size)
    local model = self:_findModel(modelName)
    if not model then
        return DoNotif("Model '" .. tostring(modelName) .. "' not found.", 3)
    end

    -- Clean up any previous UI for this model to avoid duplicates
    if self.State.ActiveUIs[model] then
        self.State.ActiveUIs[model]:Destroy()
        self.State.ActiveUIs[model] = nil
    end

    local tool = self:_getToolFromModel(model)
    if not tool then
        return DoNotif("No tool found in model '" .. model.Name .. "'.", 3)
    end

    local parts = {}
    for _, p in ipairs(tool:GetDescendants()) do
        if p:IsA("BasePart") then
            table.insert(parts, p)
        end
    end

    if #parts == 0 then
        return DoNotif("Tool '" .. tool.Name .. "' has no parts to modify.", 3)
    end

    -- Create UI for part selection (similar to existing Reach module)
    local ui = Instance.new("ScreenGui")
    ui.Name = "ModelReachPartSelector"
    NaProtectUI(ui)
    self.State.ActiveUIs[model] = ui

    local frame = Instance.new("Frame", ui)
    frame.Size = UDim2.fromOffset(250, 200)
    frame.Position = UDim2.new(0.5, -125, 0.5, -100)
    frame.BackgroundColor3 = Color3.fromRGB(35, 35, 45)
    Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 8)

    local title = Instance.new("TextLabel", frame)
    title.Size = UDim2.new(1, 0, 0, 30)
    title.BackgroundTransparency = 1
    title.Font = Enum.Font.Code
    title.Text = "Select a Part from " .. tool.Name
    title.TextColor3 = Color3.fromRGB(200, 220, 255)
    title.TextSize = 16

    local scroll = Instance.new("ScrollingFrame", frame)
    scroll.Size = UDim2.new(1, -20, 1, -40)
    scroll.Position = UDim2.fromOffset(10, 35)
    scroll.BackgroundColor3 = frame.BackgroundColor3
    scroll.BorderSizePixel = 0
    scroll.ScrollBarThickness = 6

    local layout = Instance.new("UIListLayout", scroll)
    layout.Padding = UDim.new(0, 5)

    for _, part in ipairs(parts) do
        local btn = Instance.new("TextButton", scroll)
        btn.Size = UDim2.new(1, 0, 0, 30)
        btn.BackgroundColor3 = Color3.fromRGB(50, 50, 65)
        btn.TextColor3 = Color3.fromRGB(220, 220, 230)
        btn.Font = Enum.Font.Code
        btn.Text = part.Name
        btn.TextSize = 14
        Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 4)

        btn.MouseButton1Click:Connect(function()
            if not part or not part.Parent then
                ui:Destroy()
                self.State.ActiveUIs[model] = nil
                return DoNotif("Part no longer exists.", 3)
            end

            -- Store original size if not already stored
            if not part:FindFirstChild("OGSize3") then
                local v = Instance.new("Vector3Value", part)
                v.Name = "OGSize3"
                v.Value = part.Size
            end

            -- Remove old selection box if it exists
            if part:FindFirstChild("FunTIMES") then
                part.FunTIMES:Destroy()
            end

            -- Add new selection box
            local sb = Instance.new("SelectionBox", part)
            sb.Adornee = part
            sb.Name = "FunTIMES"
            sb.LineThickness = 0.02
            sb.Color3 = reachType == "box" and Color3.fromRGB(0, 100, 255) or Color3.fromRGB(255, 0, 0)

            -- Apply size change
            if reachType == "box" then
                part.Size = Vector3.one * size
            else -- directional
                part.Size = Vector3.new(part.Size.X, part.Size.Y, size)
            end
            part.Massless = true

            -- Clean up UI
            ui:Destroy()
            self.State.ActiveUIs[model] = nil
            DoNotif("Applied reach to '" .. part.Name .. "' in model '" .. model.Name .. "'.", 3)
        end)
    end
end

-- Function to reset reach on a model's tool
function Modules.ModelReach:Reset(modelName)
    local model = self:_findModel(modelName)
    if not model then
        return DoNotif("Model '" .. tostring(modelName) .. "' not found.", 3)
    end

    local tool = self:_getToolFromModel(model)
    local wasReset = false
    
    local descendants = tool and tool:GetDescendants() or model:GetDescendants()

    for _, p in ipairs(descendants) do
        if p:IsA("BasePart") then
            if p:FindFirstChild("OGSize3") then
                p.Size = p.OGSize3.Value
                p.OGSize3:Destroy()
                wasReset = true
            end
            if p:FindFirstChild("FunTIMES") then
                p.FunTIMES:Destroy()
                wasReset = true
            end
        end
    end
    
    if wasReset then
        DoNotif("Tool reach reset for model '" .. model.Name .. "'.", 3)
    else
        DoNotif("No active reach found on model '" .. model.Name .. "'.", 3)
    end
end

Modules.IDE = { State = { UI = nil } }; function Modules.IDE:Toggle() if self.State.UI then self.State.UI:Destroy(); self.State.UI = nil; return end; local u = Instance.new("ScreenGui"); u.Name = "IDE_UI"; NaProtectUI(u); self.State.UI = u; local f = Instance.new("Frame", u); f.Size = UDim2.fromOffset(550, 400); f.Position = UDim2.new(0.5, -275, 0.5, -200); f.BackgroundColor3 = Color3.fromRGB(35, 35, 45); Instance.new("UICorner", f).CornerRadius = UDim.new(0, 8); local h = Instance.new("Frame", f); h.Size = UDim2.new(1, 0, 0, 32); h.BackgroundColor3 = Color3.fromRGB(25, 25, 35); local t = Instance.new("TextLabel", h); t.Size = UDim2.new(1, -30, 1, 0); t.Position = UDim2.fromOffset(10, 0); t.BackgroundTransparency = 1; t.Font = Enum.Font.Code; t.Text = "Zuka IDE"; t.TextColor3 = Color3.fromRGB(200, 220, 255); t.TextXAlignment = Enum.TextXAlignment.Left; t.TextSize = 16; local c = Instance.new("TextButton", h); c.Size = UDim2.fromOffset(32, 32); c.Position = UDim2.new(1, -32, 0, 0); c.BackgroundTransparency = 1; c.Font = Enum.Font.Code; c.Text = "X"; c.TextColor3 = Color3.fromRGB(200, 200, 220); c.TextSize = 20; c.MouseButton1Click:Connect(function() self:Toggle() end); local sf = Instance.new("ScrollingFrame", f); sf.Size = UDim2.new(1, -20, 1, -82); sf.Position = UDim2.fromOffset(10, 37); sf.BackgroundColor3 = Color3.fromRGB(25, 25, 35); sf.BorderSizePixel = 0; sf.ScrollBarThickness = 8; local tb = Instance.new("TextBox", sf); tb.Size = UDim2.new(1, 0, 0, 0); tb.AutomaticSize = Enum.AutomaticSize.Y; tb.BackgroundColor3 = Color3.fromRGB(25, 25, 35); tb.MultiLine = true; tb.Font = Enum.Font.Code; tb.TextColor3 = Color3.fromRGB(220, 220, 230); tb.TextSize = 14; tb.TextXAlignment = Enum.TextXAlignment.Left; tb.TextYAlignment = Enum.TextYAlignment.Top; tb.ClearTextOnFocus = false; local eb = Instance.new("TextButton", f); eb.Size = UDim2.fromOffset(100, 30); eb.Position = UDim2.new(1, -120, 1, -40); eb.BackgroundColor3 = Color3.fromRGB(80, 160, 80); eb.Font = Enum.Font.Code; eb.Text = "Execute"; eb.TextColor3 = Color3.white; eb.TextSize = 16; Instance.new("UICorner", eb).CornerRadius = UDim.new(0, 5); local cb = Instance.new("TextButton", f); cb.Size = UDim2.fromOffset(80, 30); cb.Position = UDim2.new(1, -210, 1, -40); cb.BackgroundColor3 = Color3.fromRGB(180, 80, 80); cb.Font = Enum.Font.Code; cb.Text = "Clear"; cb.TextColor3 = Color3.white; cb.TextSize = 16; Instance.new("UICorner", cb).CornerRadius = UDim.new(0, 5); eb.MouseButton1Click:Connect(function() local code = tb.Text; if #code > 0 then local s, r = pcall(function() local f, e = loadstring(code); if typeof(f) ~= "function" then error("Syntax error: " .. tostring(e or f)) end; setfenv(f, getfenv()); f() end); if s then DoNotif("Script executed.", 3) else DoNotif("Error: " .. tostring(r), 6) end end end); cb.MouseButton1Click:Connect(function() tb.Text = "" end); local function drag(o) local d, s, p; o.InputBegan:Connect(function(i) if i.UserInputType == Enum.UserInputType.MouseButton1 or i.UserInputType == Enum.UserInputType.Touch then d, s, p = true, i.Position, o.Position; i.Changed:Connect(function() if i.UserInputState == Enum.UserInputState.End then d = false end end) end end); o.InputChanged:Connect(function(i) if (i.UserInputType == Enum.UserInputType.MouseMovement or i.UserInputType == Enum.UserInputType.Touch) and d then local delta = i.Position - s; o.Position = UDim2.new(p.X.Scale, p.X.Offset + delta.X, p.Y.Scale, p.Y.Offset + delta.Y) end end) end; drag(f) end
Modules.ESP = {
    State = {
        IsActive = false,
        Connections = {}, -- Store multiple event connections
        TrackedPlayers = {}  -- Store ESP visuals for each player
    }
}

--// --- Services ---
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

--// --- ESP Toggle Function (Rewritten) ---
function Modules.ESP:Toggle()
    self.State.IsActive = not self.State.IsActive

    if self.State.IsActive then
        --// --- LOGIC FOR ENABLING ESP ---

        -- Helper function to create ESP visuals for a single player
        local function createEspForPlayer(player)
            -- Don't create ESP for the local player
            if player == LocalPlayer then return end

            local function setupVisuals(character)
                -- Clean up old visuals if they somehow exist
                if self.State.TrackedPlayers[player] then
                    self.State.TrackedPlayers[player].Highlight:Destroy()
                    self.State.TrackedPlayers[player].Billboard:Destroy()
                end

                local head = character:WaitForChild("Head")

                -- Create Highlight
                local highlight = Instance.new("Highlight")
                highlight.FillColor = Color3.fromRGB(255, 60, 60)
                highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
                highlight.FillTransparency = 0.8
                highlight.OutlineTransparency = 0.3
                highlight.Parent = character

                -- Create Billboard GUI
                local billboard = Instance.new("BillboardGui")
                billboard.Adornee = head
                billboard.AlwaysOnTop = true
                billboard.Size = UDim2.new(0, 200, 0, 50)
                billboard.StudsOffset = Vector3.new(0, 2.5, 0)
                billboard.Parent = head

                local nameLabel = Instance.new("TextLabel", billboard)
                nameLabel.Size = UDim2.new(1, 0, 0.5, 0)
                nameLabel.Text = player.Name
                nameLabel.BackgroundTransparency = 1
                nameLabel.Font = Enum.Font.Code
                nameLabel.TextSize = 18
                nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)

                local teamLabel = Instance.new("TextLabel", billboard)
                teamLabel.Size = UDim2.new(1, 0, 0.5, 0)
                teamLabel.Position = UDim2.new(0, 0, 0.5, 0)
                teamLabel.BackgroundTransparency = 1
                teamLabel.Font = Enum.Font.Code
                teamLabel.TextSize = 14
                if player.Team then
                    teamLabel.Text = player.Team.Name
                    teamLabel.TextColor3 = player.Team.TeamColor.Color
                else
                    teamLabel.Text = "No Team"
                    teamLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
                end

                -- Store the created visuals so we can clean them up later
                self.State.TrackedPlayers[player] = { Highlight = highlight, Billboard = billboard }
            end

            -- Run setup when the character is added
            if player.Character then
                setupVisuals(player.Character)
            end
            player.CharacterAdded:Connect(setupVisuals)
        end

        -- Helper function to remove ESP visuals for a player
        local function removeEspForPlayer(player)
            if self.State.TrackedPlayers[player] then
                self.State.TrackedPlayers[player].Highlight:Destroy()
                self.State.TrackedPlayers[player].Billboard:Destroy()
                self.State.TrackedPlayers[player] = nil
            end
        end

        -- 1. Create ESP for players already in the game
        for _, player in ipairs(Players:GetPlayers()) do
            createEspForPlayer(player)
        end

        -- 2. Connect to events for players joining and leaving
        self.State.Connections.PlayerAdded = Players.PlayerAdded:Connect(createEspForPlayer)
        self.State.Connections.PlayerRemoving = Players.PlayerRemoving:Connect(removeEspForPlayer)

    else
        --// --- LOGIC FOR DISABLING ESP ---

        -- Disconnect all event connections to prevent memory leaks
        for _, connection in pairs(self.State.Connections) do
            connection:Disconnect()
        end
        self.State.Connections = {}

        -- Destroy all created ESP visuals
        for _, data in pairs(self.State.TrackedPlayers) do
            data.Highlight:Destroy()
            data.Billboard:Destroy()
        end
        self.State.TrackedPlayers = {}
    end

    -- DoNotif("ESP " .. (self.State.IsActive and "Enabled" or "Disabled"), 3) -- Assuming you have a DoNotif function
end

Modules.ClickTP = { State = { IsActive = false, Connection = nil } };
function Modules.ClickTP:Toggle()
    self.State.IsActive = not self.State.IsActive
    if self.State.IsActive then
        self.State.Connection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
            if not gameProcessed and input.KeyCode == Enum.KeyCode.LeftControl then
                local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                if not hrp then return end
                
                -- Modern way to get mouse position in 3D space
                local mouseLocation = UserInputService:GetMouseLocation()
                local mouseRay = Workspace.CurrentCamera:ScreenPointToRay(mouseLocation.X, mouseLocation.Y)
                
                local raycastParams = RaycastParams.new()
                raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
                raycastParams.FilterDescendantsInstances = {LocalPlayer.Character}
                
                local result = Workspace:Raycast(mouseRay.Origin, mouseRay.Direction * 1000, raycastParams)
                
                if result and result.Position then
                    hrp.CFrame = CFrame.new(result.Position)
                end
            end
        end)
    else
        if self.State.Connection then
            self.State.Connection:Disconnect()
            self.State.Connection = nil
        end
    end
    DoNotif("Click TP " .. (self.State.IsActive and "Enabled" or "Disabled"), 3)
end

Modules.GrabTools = { State = { IsActive = false, Connection = nil } }; function Modules.GrabTools:Toggle() self.State.IsActive = not self.State.IsActive; if self.State.IsActive then self.State.Connection = workspace.ChildAdded:Connect(function(c) if c:IsA("Tool") then local bp = LocalPlayer:FindFirstChildOfClass("Backpack"); if bp then c:Clone().Parent = bp; DoNotif("Grabbed " .. c.Name, 2) end end end) else if self.State.Connection then self.State.Connection:Disconnect(); self.State.Connection = nil end end; DoNotif("Grab Tools " .. (self.State.IsActive and "Enabled" or "Disabled"), 3) end

Modules.AntiKick = { State = { IsHooked = false, Originals = { kicks = {} } } }; function Modules.AntiKick:Enable() if self.State.IsHooked then return end; local getRawMetatable = (debug and debug.getmetatable) or getrawmetatable; local setReadOnly = setreadonly or (make_writeable and function(t, ro) if ro then make_readonly(t) else make_writeable(t) end end); if not (getRawMetatable and setReadOnly and newcclosure and hookfunction and getnamecallmethod) then return DoNotif("Your environment does not support the required functions for AntiKick.", 5) end; local meta = getRawMetatable(game); if not meta then return DoNotif("Could not get game metatable.", 3) end; if not LocalPlayer then return DoNotif("LocalPlayer not found.", 3) end; self.State.Originals.namecall = meta.__namecall; self.State.Originals.index = meta.__index; self.State.Originals.newindex = meta.__newindex; for _, kickFunc in ipairs({ LocalPlayer.Kick, LocalPlayer.kick }) do if type(kickFunc) == "function" then local originalKick; originalKick = hookfunction(kickFunc, newcclosure(function(self, ...) if self == LocalPlayer then DoNotif("Kick blocked (direct hook).", 2); return end; return originalKick(self, ...) end)); self.State.Originals.kicks[kickFunc] = originalKick end end; setReadOnly(meta, false); meta.__namecall = newcclosure(function(self, ...) local method = getnamecallmethod(); if self == LocalPlayer and method and method:lower() == "kick" then DoNotif("Kick blocked (__namecall).", 2); return end; return self.State.Originals.namecall(self, ...) end); meta.__index = newcclosure(function(self, key) if self == LocalPlayer then local k = tostring(key):lower(); if k:find("kick") or k:find("destroy") then DoNotif("Blocked access to: " .. tostring(key), 2); return function() end end end; return self.State.Originals.index(self, key) end); meta.__newindex = newcclosure(function(self, key, value) if self == LocalPlayer then local k = tostring(key):lower(); if k:find("kick") or k:find("destroy") then DoNotif("Blocked overwrite of: " .. tostring(key), 2); return end end; return self.State.Originals.newindex(self, key, value) end); setReadOnly(meta, true); self.State.IsHooked = true; DoNotif("Anti-Kick enabled.", 3) end; function Modules.AntiKick:Disable() if not self.State.IsHooked then return end; local getRawMetatable = (debug and debug.getmetatable) or getrawmetatable; local setReadOnly = setreadonly or (make_writeable and function(t, ro) if ro then make_readonly(t) else make_writeable(t) end end); if unhookfunction then for func, orig in pairs(self.State.Originals.kicks) do unhookfunction(func) end end; local meta = getRawMetatable and getRawMetatable(game); if meta and setReadOnly then setReadOnly(meta, false); meta.__namecall = self.State.Originals.namecall; meta.__index = self.State.Originals.index; meta.__newindex = self.State.Originals.newindex; setReadOnly(meta, true) end; self.State.IsHooked = false; self.State.Originals = { kicks = {} }; DoNotif("Anti-Kick disabled.", 3) end; function Modules.AntiKick:Toggle() if self.State.IsHooked then self:Disable() else self:Enable() end end
Modules.Decompiler = {State = {IsInitialized = false}}; function Modules.Decompiler:Initialize() if self.State.IsInitialized then return DoNotif("Decompiler is already initialized.", 3) end; if not getscriptbytecode then return DoNotif("Decompiler Error: 'getscriptbytecode' is not available in your environment.", 5) end; local httpRequest = (syn and syn.request) or http_request; if not httpRequest then return DoNotif("Decompiler Error: A compatible HTTP POST function (e.g., syn.request) is required.", 5) end; task.spawn(function() local API_URL = "http://api.plusgiant5.com"; local last_call_time = 0; local function callAPI(endpoint, scriptInstance) local success, bytecode = pcall(getscriptbytecode, scriptInstance); if not success then DoNotif("Failed to get bytecode: " .. tostring(bytecode), 4); return end; local time_elapsed = os.clock() - last_call_time; if time_elapsed < 0.5 then task.wait(0.5 - time_elapsed) end; local success, httpResult = pcall(httpRequest, {Url = API_URL .. endpoint, Body = bytecode, Method = "POST", Headers = { ["Content-Type"] = "text/plain" }}); last_call_time = os.clock(); if not success then DoNotif("HTTP request failed: " .. tostring(httpResult), 5); return end; if httpResult.StatusCode == 200 then return httpResult.Body else DoNotif("API Error " .. httpResult.StatusCode .. ": " .. httpResult.StatusMessage, 4); return end end; local function decompile_func(scriptInstance) if not (scriptInstance and (scriptInstance:IsA("LocalScript") or scriptInstance:IsA("ModuleScript"))) then warn("Decompile target must be a LocalScript or ModuleScript instance."); return nil end; return callAPI("/konstant/decompile", scriptInstance) end; local function disassemble_func(scriptInstance) if not (scriptInstance and (scriptInstance:IsA("LocalScript") or scriptInstance:IsA("ModuleScript"))) then warn("Disassemble target must be a LocalScript or ModuleScript instance."); return nil end; return callAPI("/konstant/disassemble", scriptInstance) end; local env = getfenv(); env.decompile = decompile_func; env.disassemble = disassemble_func; self.State.IsInitialized = true; DoNotif("Decompiler initialized.", 4); DoNotif("Use 'decompile(script_instance)' in the IDE or your executor.", 6) end) end
Modules.Godmode = { State = { IsEnabled = false, Method = nil, UI = nil, Connection = nil, LastHealth = 100 } }; function Modules.Godmode:_CleanupUI() if self.State.UI then self.State.UI:Destroy(); self.State.UI = nil end end; function Modules.Godmode:Disable() if not self.State.IsEnabled then return end; self:_CleanupUI(); local char = LocalPlayer.Character; if self.State.Method == "ForceField" and char then local ff = char:FindFirstChild("ZukaGodmodeFF"); if ff then ff:Destroy() end elseif self.State.Method == "HealthLock" and self.State.Connection then self.State.Connection:Disconnect(); self.State.Connection = nil end; self.State.IsEnabled = false; self.State.Method = nil; DoNotif("Godmode OFF", 2) end; function Modules.Godmode:EnableForceField() self:Disable(); local char = LocalPlayer.Character; if not char then return DoNotif("Character not found.", 3) end; local ff = Instance.new("ForceField", char); ff.Name = "ZukaGodmodeFF"; self.State.IsEnabled = true; self.State.Method = "ForceField"; DoNotif("Godmode ON (ForceField)", 2) end; function Modules.Godmode:EnableHealthLock() self:Disable(); local char = LocalPlayer.Character; local humanoid = char and char:FindFirstChildOfClass("Humanoid"); if not humanoid then return DoNotif("Humanoid not found.", 3) end; self.State.LastHealth = humanoid.Health; self.State.Connection = humanoid.HealthChanged:Connect(function(newHealth) if newHealth < self.State.LastHealth and newHealth > 0 then humanoid.Health = self.State.LastHealth else self.State.LastHealth = newHealth end end); self.State.IsEnabled = true; self.State.Method = "HealthLock"; DoNotif("Godmode ON (Health Lock)", 2) end; function Modules.Godmode:ShowMenu() self:_CleanupUI(); local gui = Instance.new("ScreenGui"); gui.Name = "GodmodeUI"; NaProtectUI(gui); self.State.UI = gui; local frame = Instance.new("Frame", gui); frame.Size = UDim2.fromOffset(250, 210); frame.Position = UDim2.new(0.5, -125, 0.5, -105); frame.BackgroundColor3 = Color3.fromRGB(35, 35, 45); Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 8); local title = Instance.new("TextLabel", frame); title.Size = UDim2.new(1, 0, 0, 30); title.BackgroundTransparency = 1; title.Font = Enum.Font.Code; title.Text = "Godmode Methods"; title.TextColor3 = Color3.fromRGB(200, 220, 255); title.TextSize = 16; local buttonContainer = Instance.new("Frame", frame); buttonContainer.Size = UDim2.new(1, -20, 1, -40); buttonContainer.Position = UDim2.fromOffset(10, 35); buttonContainer.BackgroundTransparency = 1; local list = Instance.new("UIListLayout", buttonContainer); list.Padding = UDim.new(0, 5); list.SortOrder = Enum.SortOrder.LayoutOrder; local function makeButton(text, callback) local btn = Instance.new("TextButton", buttonContainer); btn.Size = UDim2.new(1, 0, 0, 35); btn.BackgroundColor3 = Color3.fromRGB(50, 50, 65); btn.TextColor3 = Color3.fromRGB(220, 220, 230); btn.Font = Enum.Font.Code; btn.Text = text; btn.TextSize = 14; Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 4); btn.MouseButton1Click:Connect(callback); return btn end; makeButton("Enable: ForceField (Visual)", function() self:_CleanupUI(); self:EnableForceField() end); makeButton("Enable: Health Lock (Silent)", function() self:_CleanupUI(); self:EnableHealthLock() end); if self.State.IsEnabled then makeButton("Disable Godmode", function() self:_CleanupUI(); self:Disable() end) end; makeButton("Close", function() self:_CleanupUI() end).BackgroundColor3 = Color3.fromRGB(180, 80, 80) end; function Modules.Godmode:HandleCommand(args) local choice = args[1] and args[1]:lower() or nil; if choice == "strong" or choice == "forcefield" or choice == "ff" then return self:EnableForceField() end; if choice == "hook" or choice == "hooking" or choice == "healthlock" or choice == "lock" then return self:EnableHealthLock() end; if choice == "off" or choice == "disable" then return self:Disable() end; self:ShowMenu() end
Modules.iBTools = { State = { IsActive = false, Tool = nil, UI = nil, Highlight = nil, Connections = {}, History = {}, SaveHistory = {}, CurrentPart = nil, CurrentMode = "delete" } }; function Modules.iBTools:_CleanupUI() if self.State.UI then self.State.UI:Destroy() end; if self.State.Highlight then self.State.Highlight:Destroy() end; for _, conn in ipairs(self.State.Connections) do conn:Disconnect() end; self.State.UI, self.State.Highlight = nil, nil; table.clear(self.State.Connections) end; function Modules.iBTools:Disable() if not self.State.IsActive then return end; self:_CleanupUI(); if self.State.Tool then self.State.Tool:Destroy() end; self.State = { IsActive = false, Tool = nil, UI = nil, Highlight = nil, Connections = {}, History = {}, SaveHistory = {}, CurrentPart = nil, CurrentMode = "delete" }; DoNotif("iBTools unloaded.", 3) end; function Modules.iBTools:Enable() if self.State.IsActive then return DoNotif("iBTools is already active.", 3) end; local backpack = LocalPlayer:FindFirstChildOfClass("Backpack"); if not backpack then return DoNotif("Backpack not found.", 3) end; self.State.IsActive = true; self.State.Tool = Instance.new("Tool", backpack); self.State.Tool.Name = "iBTools"; self.State.Tool.RequiresHandle = false; self.State.Tool.Equipped:Connect(function(mouse) local state = self.State; state.Highlight = Instance.new("SelectionBox"); state.Highlight.Name = "iBToolsSelection"; state.Highlight.LineThickness = 0.04; state.Highlight.Color3 = Color3.fromRGB(0, 170, 255); state.Highlight.Parent = workspace.CurrentCamera; local function formatVectorString(vec) return string.format("Vector3.new(%s,%s,%s)", tostring(vec.X), tostring(vec.Y), tostring(vec.Z)) end; local function updateStatus(part) if not state.UI then return end; local statusLabel = state.UI:FindFirstChild("Panel", true) and state.UI.Panel:FindFirstChild("Status"); if not statusLabel then return end; local targetText = "none"; if part then targetText = part:GetFullName() end; statusLabel.Text = string.format("Mode: %s | Target: %s", state.CurrentMode:upper(), targetText) end; local function setTarget(part) if part and not part:IsA("BasePart") then part = nil end; state.CurrentPart = part; if state.Highlight then state.Highlight.Adornee = part end; updateStatus(part) end; local modeHandlers = { delete = function(part) table.insert(state.History, {part = part, parent = part.Parent, cframe = part.CFrame}); table.insert(state.SaveHistory, {name = part.Name, position = part.Position}); part.Parent = nil; setTarget(nil); DoNotif("Deleted '"..part.Name.."'", 2) end, anchor = function(part) part.Anchored = not part.Anchored; updateStatus(part); DoNotif(string.format("%s anchored %s", part.Name, part.Anchored and "enabled" or "disabled"), 2) end, collide = function(part) part.CanCollide = not part.CanCollide; updateStatus(part); DoNotif(string.format("%s CanCollide %s", part.Name, part.CanCollide and "enabled" or "disabled"), 2) end }; local uiActions = { setMode = function(mode) state.CurrentMode = mode; updateStatus(state.CurrentPart) end, undo = function() local r = table.remove(state.History); if r then r.part.Parent = r.parent; pcall(function() r.part.CFrame = r.cframe end); setTarget(r.part); DoNotif("Restored '"..r.part.Name.."'", 2) else DoNotif("Nothing to undo.", 2) end end, copy = function() if #state.SaveHistory == 0 then return DoNotif("No deleted parts to export.", 3) end; local l = {}; for _, d in ipairs(state.SaveHistory) do table.insert(l, string.format("for _,v in ipairs(workspace:FindPartsInRegion3(Region3.new(%s, %s), nil, math.huge)) do if v.Name == %q then v:Destroy() end end", formatVectorString(d.position), formatVectorString(d.position), d.name)) end; setclipboard(table.concat(l, "\n")); DoNotif("Copied delete script to clipboard.", 3) end }; local gui = Instance.new("ScreenGui"); gui.Name = "iBToolsUI"; NaProtectUI(gui); self.State.UI = gui; local f = Instance.new("Frame", gui); f.Name = "Panel"; f.Size = UDim2.new(0, 240, 0, 260); f.Position = UDim2.new(0.05, 0, 0.4, 0); f.BackgroundColor3 = Color3.fromRGB(26, 26, 26); Instance.new("UICorner", f).CornerRadius = UDim.new(0, 8); local h = Instance.new("Frame", f); h.Name = "Header"; h.Size = UDim2.new(1, 0, 0, 36); h.BackgroundColor3 = Color3.fromRGB(38, 38, 38); h.Active = true; local t = Instance.new("TextLabel", h); t.BackgroundTransparency=1;t.Font=Enum.Font.GothamSemibold;t.Text="iB Tools";t.Size=UDim2.new(1,-40,1,0);t.Position=UDim2.new(0,12,0,0);t.TextColor3=Color3.new(1,1,1);t.TextXAlignment=Enum.TextXAlignment.Left;local s=Instance.new("TextLabel",f);s.Name="Status";s.BackgroundTransparency=1;s.Size=UDim2.new(1,-24,0,20);s.Position=UDim2.new(0,12,0,40);s.Font=Enum.Font.Code;s.TextColor3=Color3.fromRGB(200,200,200);s.TextXAlignment=Enum.TextXAlignment.Left;s.Text="Mode: DELETE | Target: none";local bH=Instance.new("Frame",f);bH.BackgroundTransparency=1;bH.Size=UDim2.new(1,-24,1,-72);bH.Position=UDim2.new(0,12,0,68);local l=Instance.new("UIListLayout",bH);l.Padding=UDim.new(0,6);local mB={};local function btn(txt)local b=Instance.new("TextButton",bH);b.Name=txt;b.Size=UDim2.new(1,0,0,32);b.Font=Enum.Font.GothamSemibold;b.Text=txt;b.TextColor3=Color3.new(1,1,1);b.TextSize=14;local c=Instance.new("UICorner",b);c.CornerRadius=UDim.new(0,5);return b end;local function rMB()for m,b in pairs(mB)do b.BackgroundColor3=(state.CurrentMode==m and Color3.fromRGB(80,110,255)or Color3.fromRGB(52,52,52))end end;for m,lbl in pairs({delete="Delete",anchor="Toggle Anchor",collide="Toggle CanCollide"})do local b=btn(lbl);mB[m]=b;b.MouseButton1Click:Connect(function()uiActions.setMode(m);rMB()end)end;btn("Undo Last Delete").MouseButton1Click:Connect(uiActions.undo);btn("Copy Delete Script").MouseButton1Click:Connect(uiActions.copy);local function drag(o,h) local d,s,p; h.InputBegan:Connect(function(i) if i.UserInputType==Enum.UserInputType.MouseButton1 then d,s,p=true,i.Position,o.Position;i.Changed:Connect(function()if i.UserInputState==Enum.UserInputState.End then d=false end end)end end); h.InputChanged:Connect(function(i) if i.UserInputType==Enum.UserInputType.MouseMovement and d then o.Position=UDim2.new(p.X.Scale,p.X.Offset+i.Position.X-s.X,p.Y.Scale,p.Y.Offset+i.Position.Y-s.Y)end end)end;drag(f,h);rMB(); table.insert(state.Connections, mouse.Move:Connect(function() setTarget(mouse.Target) end)); table.insert(state.Connections, mouse.Button1Down:Connect(function() if state.CurrentPart then modeHandlers[state.CurrentMode](state.CurrentPart) end end)) end); self.State.Tool.Unequipped:Connect(function() self:_CleanupUI() end); self.State.Tool.AncestryChanged:Connect(function(_, parent) if not parent then self:Disable() end end); DoNotif("iBTools loaded. Equip the tool to use it.", 3) end; function Modules.iBTools:Toggle() if self.State.IsActive then self:Disable() else self:Enable() end end

Modules.AntiKB = {
    State = {
        IsActive = false,
        HealthConnection = nil,
        CharacterConnection = nil,
        LastHealth = 100 
    }
}

function Modules.AntiKB:_cleanup()
    if self.State.HealthConnection then
        self.State.HealthConnection:Disconnect()
        self.State.HealthConnection = nil
    end
    if self.State.CharacterConnection then
        self.State.CharacterConnection:Disconnect()
        self.State.CharacterConnection = nil
    end
end

function Modules.AntiKB:Disable()
    if not self.State.IsActive then return end
    self.State.IsActive = false
    self:_cleanup()
    DoNotif("Anti Kill Brick disabled.", 3)
end

function Modules.AntiKB:Enable()
    if self.State.IsActive then return end
    local char = LocalPlayer.Character
    local humanoid = char and char:FindFirstChildOfClass("Humanoid")
    
    -- Function to re-enable on character respawn
    local function onCharacterAdded()
        task.wait(0.1) -- Small wait for Humanoid to fully initialize
        if LocalPlayer.Character and self.State.IsActive then
            self:Enable() -- Re-run enable to re-hook the new Humanoid
        end
    end

    if not humanoid then
        -- If character is not found, hook CharacterAdded and wait
        self.State.CharacterConnection = LocalPlayer.CharacterAdded:Connect(onCharacterAdded)
        return DoNotif("Character not available. Waiting for spawn.", 3)
    end
    
    self:Disable() -- Clean any previous state, including CharacterConnection
    self.State.IsActive = true
    
    -- Set LastHealth based on current Humanoid health
    self.State.LastHealth = humanoid.Health or 100
    
    -- Health Changed Listener: Core Logic for Anti-Damage
    self.State.HealthConnection = humanoid.HealthChanged:Connect(function(newHealth)
        if not self.State.IsActive then return end
        
        -- If damage was taken (health dropped) but the player is not dead
        if newHealth < self.State.LastHealth and newHealth > 0 then
            humanoid.Health = self.State.LastHealth -- Restore health
        end
        
        -- Always update LastHealth with the current Humanoid health
        self.State.LastHealth = humanoid.Health
    end)
    
    -- Handle respawns to re-hook the HealthChanged event to the new Humanoid
    self.State.CharacterConnection = LocalPlayer.CharacterAdded:Connect(onCharacterAdded)

    DoNotif("Anti Kill Brick enabled (Health Lock).", 3)
end

function Modules.AntiKB:Toggle()
    if self.State.IsActive then
        self:Disable()
    else
        self:Enable()
    end
end

Modules.PartSelector = {
    State = {
        IsActive = false,
        Connection = nil,
        UI = nil
    }
}

function Modules.PartSelector:Disable()
    if not self.State.IsActive then return end
    self.State.IsActive = false

    if self.State.Connection then
        self.State.Connection:Disconnect()
        self.State.Connection = nil
    end

    if self.State.UI then
        self.State.UI:Destroy()
        self.State.UI = nil
    end

    DoNotif("Part Selector disabled.", 3)
end

function Modules.PartSelector:Enable()
    if self.State.IsActive then return end
    self:Disable() -- Ensure clean state
    self.State.IsActive = true

    --// --- Services & Player Objects ---
    local RunService = game:GetService("RunService")
    local mouse = LocalPlayer:GetMouse() -- Using the reliable legacy mouse object

    --// --- UI Creation ---
    local ui = Instance.new("ScreenGui")
    ui.Name = "PartSelectorUI"
    NaProtectUI(ui)
    self.State.UI = ui

    local mainFrame = Instance.new("Frame", ui)
    mainFrame.Size = UDim2.fromOffset(350, 110)
    mainFrame.Position = UDim2.new(0.5, -175, 1, -130)
    mainFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
    mainFrame.BackgroundTransparency = 0.2
    Instance.new("UICorner", mainFrame).CornerRadius = UDim.new(0, 6)
    Instance.new("UIStroke", mainFrame).Color = Color3.fromRGB(80, 80, 100)

    local title = Instance.new("TextLabel", mainFrame)
    title.Size = UDim2.new(1, 0, 0, 25)
    title.BackgroundColor3 = Color3.fromRGB(55, 55, 70)
    title.Font = Enum.Font.GothamSemibold
    title.Text = "Part & Model Selector"
    title.TextColor3 = Color3.fromRGB(220, 220, 255)
    title.TextSize = 16
    local titleCorner = Instance.new("UICorner", title)
    titleCorner.CornerRadius = UDim.new(0, 6)
    
    local contentFrame = Instance.new("Frame", mainFrame)
    contentFrame.Size = UDim2.new(1, 0, 1, -25)
    contentFrame.Position = UDim2.fromOffset(0, 25)
    contentFrame.BackgroundTransparency = 1
    
    local listLayout = Instance.new("UIListLayout", contentFrame)
    listLayout.Padding = UDim.new(0, 4)
    listLayout.SortOrder = Enum.SortOrder.LayoutOrder
    listLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    
    local padding = Instance.new("UIPadding", contentFrame)
    padding.PaddingTop = UDim.new(0, 5)
    padding.PaddingLeft = UDim.new(0, 5)
    padding.PaddingRight = UDim.new(0, 5)

    local fullPathLabel = Instance.new("TextLabel", contentFrame)
    fullPathLabel.Name = "FullPathLabel"
    fullPathLabel.Size = UDim2.new(1, 0, 0, 16)
    fullPathLabel.BackgroundTransparency = 1
    fullPathLabel.Font = Enum.Font.Code
    fullPathLabel.Text = "Path: None"
    fullPathLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    fullPathLabel.TextXAlignment = Enum.TextXAlignment.Left
    fullPathLabel.TextSize = 12

    local modelNameLabel = Instance.new("TextLabel", contentFrame)
    modelNameLabel.Name = "ModelNameLabel"
    modelNameLabel.Size = UDim2.new(1, 0, 0, 18)
    modelNameLabel.BackgroundTransparency = 1
    modelNameLabel.Font = Enum.Font.GothamBold
    modelNameLabel.Text = "Model: None"
    modelNameLabel.TextColor3 = Color3.fromRGB(80, 150, 255)
    modelNameLabel.TextXAlignment = Enum.TextXAlignment.Left
    modelNameLabel.TextSize = 14

    local copyButton = Instance.new("TextButton", contentFrame)
    copyButton.Name = "CopyButton"
    copyButton.Size = UDim2.new(1, 0, 0, 22)
    copyButton.BackgroundColor3 = Color3.fromRGB(80, 160, 80)
    copyButton.Font = Enum.Font.Code
    copyButton.Text = "Copy Model Name"
    copyButton.TextColor3 = Color3.white
    copyButton.TextSize = 14
    copyButton.Visible = false
    Instance.new("UICorner", copyButton).CornerRadius = UDim.new(0, 4)
    
    local currentModelName = nil
    copyButton.MouseButton1Click:Connect(function()
        if currentModelName then
            setclipboard(currentModelName)
            DoNotif("Copied '" .. currentModelName .. "' to clipboard.", 3)
        end
    end)
    
    --// --- CORE LOGIC (REWRITTEN) ---
    self.State.Connection = RunService.RenderStepped:Connect(function()
        -- Set the filter to ignore the player's character and our UI
        mouse.TargetFilter = LocalPlayer.Character or nil
        
        local part = mouse.Target
        
        if part then
            fullPathLabel.Text = "Path: " .. part:GetFullName()

            -- Find the top-level model in workspace
            local topModel = nil
            local ancestor = part
            while ancestor and ancestor.Parent ~= workspace do
                ancestor = ancestor.Parent
            end
            if ancestor and ancestor:IsA("Model") then
                topModel = ancestor
            end

            if topModel then
                modelNameLabel.Text = "Model: " .. topModel.Name
                copyButton.Visible = true
                currentModelName = topModel.Name
            else
                modelNameLabel.Text = "Model: (Not in a model)"
                copyButton.Visible = false
                currentModelName = nil
            end
        else
            fullPathLabel.Text = "Path: None"
            modelNameLabel.Text = "Model: None"
            copyButton.Visible = false
            currentModelName = nil
        end
    end)

    DoNotif("Part Selector enabled.", 3)
end

function Modules.PartSelector:Toggle()
    if self.State.IsActive then
        self:Disable()
    else
        self:Enable()
    end
end

local isCameraFixed = false
local originalMaxZoom = nil
local originalOcclusionMode = nil
local cameraFixConnection = nil

--==========================================================
-- Highlight Player Module
-- Description: Highlights a specific player by name.
--==========================================================

--// Services
local Players = game:GetService("Players")

--// Module Definition
Modules.HighlightPlayer = {
    State = {
        TargetPlayer = nil,
        HighlightInstance = nil,
        CharacterAddedConnection = nil
    }
}

--// Helper function to find a player by a partial name (case-insensitive)
local function findFirstPlayer(partialName)
    local lowerPartialName = string.lower(partialName)
    for _, player in ipairs(Players:GetPlayers()) do
        if string.lower(player.Name):sub(1, #lowerPartialName) == lowerPartialName then
            return player
        end
    end
    return nil
end

--// Core Logic
-- Applies the highlight effect to a given character model
function Modules.HighlightPlayer:ApplyHighlight(character)
    if not character then return end

    -- If a highlight somehow already exists, destroy it before creating a new one.
    if self.State.HighlightInstance then
        self.State.HighlightInstance:Destroy()
    end

    local highlight = Instance.new("Highlight")
    highlight.FillColor = Color3.fromRGB(0, 255, 255) -- A bright cyan for high visibility
    highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
    highlight.FillTransparency = 0.7
    highlight.OutlineTransparency = 0.2
    highlight.Parent = character

    -- Store the new highlight instance so we can manage it later
    self.State.HighlightInstance = highlight
end

-- Completely removes the highlight and disconnects any related events
function Modules.HighlightPlayer:ClearHighlight()
    if self.State.HighlightInstance then
        self.State.HighlightInstance:Destroy()
        self.State.HighlightInstance = nil
    end
    if self.State.CharacterAddedConnection then
        self.State.CharacterAddedConnection:Disconnect()
        self.State.CharacterAddedConnection = nil
    end
    if self.State.TargetPlayer then
        print("Highlight cleared from: " .. self.State.TargetPlayer.Name)
        self.State.TargetPlayer = nil
    end
end

--// Command Registration
RegisterCommand({
    Name = "highlightplayer",
    Aliases = {"highlight", "hlp", "findplayer"},
    Description = "Highlights a single player. Usage: highlight <PlayerName> | clear"
}, function(args)
    local argument = args[1]

    if not argument then
        print("Usage: highlight <PlayerName> | clear")
        return
    end

    -- Handle the command to clear the highlight
    if string.lower(argument) == "clear" or string.lower(argument) == "reset" then
        if not Modules.HighlightPlayer.State.TargetPlayer then
            print("No player is currently highlighted.")
            return
        end
        Modules.HighlightPlayer:ClearHighlight()
        return
    end

    -- Find the target player based on the provided name
    local targetPlayer = findFirstPlayer(argument)
    if not targetPlayer then
        print("Error: Player '" .. argument .. "' not found.")
        return
    end

    -- If we're targeting a new player, first clear any existing highlight.
    Modules.HighlightPlayer:ClearHighlight()

    -- Set the new target player
    Modules.HighlightPlayer.State.TargetPlayer = targetPlayer
    print("Now highlighting: " .. targetPlayer.Name)

    -- Apply the highlight to their current character if it exists
    if targetPlayer.Character then
        Modules.HighlightPlayer:ApplyHighlight(targetPlayer.Character)
    end

    -- Connect to the CharacterAdded event to re-apply the highlight on respawn
    Modules.HighlightPlayer.State.CharacterAddedConnection = targetPlayer.CharacterAdded:Connect(function(newCharacter)
        Modules.HighlightPlayer:ApplyHighlight(newCharacter)
    end)
end)

--==========================================================
-- Bypass Property Checks (Metamethod Hook)
-- Description: Bypasses local anti-cheats that check Humanoid properties like WalkSpeed.
--==========================================================

--// Services
local Players = game:GetService("Players")

--// Module Definition
Modules.BypassPropertyChecks = {
    State = {
        Enabled = false,
        OriginalMetatable = nil,
        FakeProperties = {
            WalkSpeed = 16,
            JumpPower = 50,
            JumpHeight = 7.2
        }
    }
}

--// Command Registration
RegisterCommand({
    Name = "bypasspropertychecks",
    Aliases = {"bprop", "bpc"},
    Description = "Toggles a metamethod hook to hide changes to WalkSpeed/JumpPower from local anti-cheats."
}, function(args)
    local localPlayer = Players.LocalPlayer
    local character = localPlayer and localPlayer.Character
    local humanoid = character and character:FindFirstChildOfClass("Humanoid")

    if not humanoid then
        print("Error: Humanoid not found. Cannot apply bypass.")
        return
    end

    -- Toggle the state
    Modules.BypassPropertyChecks.State.Enabled = not Modules.BypassPropertyChecks.State.Enabled

    if Modules.BypassPropertyChecks.State.Enabled then
        print("Property Check Bypass: [Enabled]")
        -- Save the original metatable so we can restore it later
        Modules.BypassPropertyChecks.State.OriginalMetatable = getmetatable(humanoid)

        local newMt = {
            __index = function(self, key)
                -- If a fake value for this property exists, return the fake value.
                if Modules.BypassPropertyChecks.State.FakeProperties[key] then
                    return Modules.BypassPropertyChecks.State.FakeProperties[key]
                end
                -- Otherwise, return the real value from the original metatable.
                return Modules.BypassPropertyChecks.State.OriginalMetatable.__index(self, key)
            end
        }
        
        -- Apply our fake metatable to the humanoid
        setmetatable(humanoid, newMt)
    else
        print("Property Check Bypass: [Disabled]")
        -- Restore the original metatable to remove our hook
        if Modules.BypassPropertyChecks.State.OriginalMetatable then
            setmetatable(humanoid, Modules.BypassPropertyChecks.State.OriginalMetatable)
            Modules.BypassPropertyChecks.State.OriginalMetatable = nil
        end
    end
end)

--==========================================================
-- Anti-CFrame Teleport Module
-- Description: Prevents the local player from being teleported by monitoring CFrame changes.
--==========================================================

--// Services
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

--// Module Definition
Modules.AntiCFrameTeleport = {
    State = {
        Enabled = false,
        Connection = nil,
        LastCFrame = nil,
        -- The max distance a player can travel in a single frame before it's considered a teleport.
        -- This value is generous to avoid false positives from flings or high-speed vehicles.
        MaxDistancePerFrame = 75
    }
}

--// Core Logic
function Modules.AntiCFrameTeleport:CheckForTeleport()
    local localPlayer = Players.LocalPlayer
    local character = localPlayer and localPlayer.Character
    local rootPart = character and character:FindFirstChild("HumanoidRootPart")

    if not rootPart then return end

    local currentCFrame = rootPart.CFrame
    
    -- If we have a previously recorded CFrame, check the distance.
    if Modules.AntiCFrameTeleport.State.LastCFrame then
        local distance = (currentCFrame.Position - Modules.AntiCFrameTeleport.State.LastCFrame.Position).Magnitude
        
        -- If the distance moved in one frame is greater than our threshold, revert it.
        if distance > Modules.AntiCFrameTeleport.State.MaxDistancePerFrame then
            rootPart.CFrame = Modules.AntiCFrameTeleport.State.LastCFrame -- Revert to the last valid CFrame
            return -- Exit early to prevent the invalid new CFrame from being saved
        end
    end
    
    -- Store the current CFrame as the last valid CFrame for the next check.
    Modules.AntiCFrameTeleport.State.LastCFrame = rootPart.CFrame
end

--// Command Registration
RegisterCommand({
    Name = "anticframetp",
    Aliases = {"antiteleport", "actp"},
    Description = "Toggles an anti-teleport system that reverts sudden CFrame changes."
}, function(args)
    -- Toggle the state
    Modules.AntiCFrameTeleport.State.Enabled = not Modules.AntiCFrameTeleport.State.Enabled

    if Modules.AntiCFrameTeleport.State.Enabled then
        print("Anti-CFrame TP: [Enabled]")
        -- Connect the check to RunService.Stepped, which runs before physics simulation.
        -- This is ideal for catching and reverting position changes before they take full effect.
        Modules.AntiCFrameTeleport.State.Connection = RunService.Stepped:Connect(function()
            Modules.AntiCFrameTeleport:CheckForTeleport()
        end)
    else
        print("Anti-CFrame TP: [Disabled]")
        -- Disconnect the event to ensure no performance is used when disabled.
        if Modules.AntiCFrameTeleport.State.Connection then
            Modules.AntiCFrameTeleport.State.Connection:Disconnect()
            Modules.AntiCFrameTeleport.State.Connection = nil
            Modules.AntiCFrameTeleport.State.LastCFrame = nil -- Clear the last saved CFrame
        end
    end
end)

--==========================================================
-- FOV Changer Module
-- Description: Allows the user to change their camera's field of view.
--==========================================================

--// Services
local Workspace = game:GetService("Workspace")

--// Module Definition
Modules.FovChanger = {
    State = {
        -- The default FOV in Roblox is 70. Storing it here makes it easy to change.
        DefaultFov = 70
    }
}

--// Command Registration
RegisterCommand({
    Name = "fov",
    Aliases = {"fieldofview", "camfov"},
    Description = "Changes the client's camera Field of View. Usage: fov <1-120> | reset"
}, function(args)
    local camera = Workspace.CurrentCamera
    if not camera then
        print("Error: Could not find the game camera.")
        return
    end

    local argument = args[1]

    -- If no argument is provided, show current FOV and usage instructions.
    if not argument then
        print("Usage: fov <number between 1-120> or 'reset'")
        print("Your current FOV is: " .. camera.FieldOfView)
        return
    end

    -- Handle the 'reset' argument to return to default.
    if string.lower(argument) == "reset" then
        camera.FieldOfView = Modules.FovChanger.State.DefaultFov
        print("FOV has been reset to " .. Modules.FovChanger.State.DefaultFov .. ".")
        return
    end

    -- Attempt to convert the argument to a number.
    local newFov = tonumber(argument)

    -- Check if the conversion was successful.
    if not newFov then
        print("Error: Invalid argument. Please provide a number (e.g., 'fov 90') or 'reset'.")
        return
    end

    -- Clamp the number to Roblox's accepted range (1-120) to prevent errors.
    local clampedFov = math.clamp(newFov, 1, 120)
    
    -- Apply the new FOV.
    camera.FieldOfView = clampedFov
    print("Camera FOV set to " .. clampedFov .. ".")
end)

--==========================================================
-- Hitbox Alteration Module
-- Description: Shrinks the local player's character limbs to reduce their hitbox size.
--==========================================================

--// Services
local Players = game:GetService("Players")

--// Module Definition
Modules.HitboxAlter = {
    State = {
        Enabled = false,
        -- This table is crucial. It will store the original sizes of the body parts before we alter them.
        -- Format: { ["PartName"] = Vector3Size, ... }
        OriginalSizes = {},
        CharacterAddedConnection = nil,
        -- A list of all standard R6 and R15 body parts to target.
        BodyPartNames = {
            "Head", "UpperTorso", "LowerTorso", "LeftUpperArm", "LeftLowerArm", "LeftHand",
            "RightUpperArm", "RightLowerArm", "RightHand", "LeftUpperLeg", "LeftLowerLeg", "LeftFoot",
            "RightUpperLeg", "RightLowerLeg", "RightFoot", "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg"
        }
    }
}

--// Core Logic
function Modules.HitboxAlter:AlterCharacter(character)
    if not character then return end

    -- The new, very small size for the hitboxes.
    local newSize = Vector3.new(0.5, 0.5, 0.5)

    for _, partName in ipairs(self.State.BodyPartNames) do
        local part = character:FindFirstChild(partName)
        if part and part:IsA("BasePart") then
            -- IMPORTANT: Only save the original size if we haven't already.
            -- This prevents overwriting the true original size on subsequent runs (e.g., respawn).
            if not self.State.OriginalSizes[partName] then
                self.State.OriginalSizes[partName] = part.Size
            end
            part.Size = newSize
        end
    end
end

function Modules.HitboxAlter:RestoreCharacter(character)
    if not character then return end

    for partName, originalSize in pairs(self.State.OriginalSizes) do
        local part = character:FindFirstChild(partName)
        if part and part:IsA("BasePart") then
            part.Size = originalSize
        end
    end
end

-- This function will be called every time the player respawns.
function Modules.HitboxAlter:OnCharacterAdded(newCharacter)
    -- A small delay is necessary to ensure all parts are loaded before we try to alter them.
    task.wait(0.1)
    self:AlterCharacter(newCharacter)
end

--// Command Registration
RegisterCommand({
    Name = "alterhitbox",
    Aliases = {"smallhitbox", "ahb"},
    Description = "Shrinks your character's limbs to make your hitbox smaller."
}, function(args)
    -- Toggle the state
    Modules.HitboxAlter.State.Enabled = not Modules.HitboxAlter.State.Enabled
    local localPlayer = Players.LocalPlayer

    if Modules.HitboxAlter.State.Enabled then
        print("Hitbox Alteration: [Enabled]")
        
        -- Alter the current character immediately
        if localPlayer.Character then
            Modules.HitboxAlter:AlterCharacter(localPlayer.Character)
        end

        -- Connect the event for future respawns
        Modules.HitboxAlter.State.CharacterAddedConnection = localPlayer.CharacterAdded:Connect(function(char)
            Modules.HitboxAlter:OnCharacterAdded(char)
        end)
    else
        print("Hitbox Alteration: [Disabled]")
        
        -- Restore the current character immediately
        if localPlayer.Character then
            Modules.HitboxAlter:RestoreCharacter(localPlayer.Character)
        end
        
        -- Disconnect the respawn event to stop all script activity and clean up
        if Modules.HitboxAlter.State.CharacterAddedConnection then
            Modules.HitboxAlter.State.CharacterAddedConnection:Disconnect()
            Modules.HitboxAlter.State.CharacterAddedConnection = nil
        end

        -- Clear the stored sizes so they can be re-captured freshly next time.
        Modules.HitboxAlter.State.OriginalSizes = {}
    end
end)

--==========================================================
-- Set Spawn Point Module
-- Description: Sets a custom respawn location for the local player.
--==========================================================

--// Services
local Players = game:GetService("Players")

--// Module Definition
Modules.SetSpawnPoint = {
    State = {
        -- This will store the CFrame of our desired spawn point.
        CustomSpawnCFrame = nil,
        -- This will hold the connection to the CharacterAdded event so we can disconnect it later.
        CharacterAddedConnection = nil
    }
}

--// Core Logic
-- This function is called every time the player's character is added (i.e., when they respawn).
function Modules.SetSpawnPoint:OnCharacterAdded(newCharacter)
    -- Check if a custom spawn CFrame has actually been set. If not, do nothing.
    if not self.State.CustomSpawnCFrame then return end

    -- Wait for the HumanoidRootPart to exist to ensure the character is fully loaded.
    local rootPart = newCharacter:WaitForChild("HumanoidRootPart", 5) -- 5-second timeout

    if rootPart then
        -- A brief wait is crucial. It ensures the character is physically initialized
        -- before we override its position, preventing physics glitches.
        task.wait() 
        rootPart.CFrame = self.State.CustomSpawnCFrame
    end
end

--// Command Registration
RegisterCommand({
    Name = "setspawnpoint",
    Aliases = {"setspawn", "ssp"},
    Description = "Sets your respawn point to your current location. Use 'clear' to reset."
}, function(args)
    local localPlayer = Players.LocalPlayer
    local commandArg = args[1] and string.lower(args[1])

    -- Logic for clearing the spawn point
    if commandArg == "clear" or commandArg == "reset" then
        if Modules.SetSpawnPoint.State.CustomSpawnCFrame then
            Modules.SetSpawnPoint.State.CustomSpawnCFrame = nil
            print("Custom spawn point cleared. You will now use the default spawn.")
            
            -- Disconnect the event listener to stop overriding spawns
            if Modules.SetSpawnPoint.State.CharacterAddedConnection then
                Modules.SetSpawnPoint.State.CharacterAddedConnection:Disconnect()
                Modules.SetSpawnPoint.State.CharacterAddedConnection = nil
            end
        else
            print("No custom spawn point was set.")
        end
        return -- Stop execution here
    end

    -- Logic for setting the spawn point
    local character = localPlayer and localPlayer.Character
    local rootPart = character and character:FindFirstChild("HumanoidRootPart")

    if not rootPart then
        print("Error: Could not set spawn point. Player character not found.")
        return
    end

    -- Store the character's current CFrame
    Modules.SetSpawnPoint.State.CustomSpawnCFrame = rootPart.CFrame
    print("Custom spawn point set at: " .. tostring(rootPart.Position))

    -- IMPORTANT: We only create the event connection if it doesn't already exist.
    -- This prevents creating multiple duplicate connections if the user sets the spawn more than once.
    if not Modules.SetSpawnPoint.State.CharacterAddedConnection then
        Modules.SetSpawnPoint.State.CharacterAddedConnection = localPlayer.CharacterAdded:Connect(function(char)
            Modules.SetSpawnPoint:OnCharacterAdded(char)
        end)
    end
end)

--==========================================================
-- Anti-Void Module
-- Description: Prevents the player from dying to the void by teleporting them back to their last safe position.
--==========================================================

--// Services
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

--// Module Definition
Modules.AntiVoid = {
    State = {
        Enabled = false,
        Connection = nil,
        LastSafePosition = nil,
        -- The Y-axis level that triggers the anti-void. Default is based on Workspace.FallenPartsDestroyHeight.
        VoidThreshold = Workspace.FallenPartsDestroyHeight
    }
}

--// Core Logic
function Modules.AntiVoid:CheckVoid()
    local localPlayer = Players.LocalPlayer
    local character = localPlayer and localPlayer.Character
    if not character then return end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local rootPart = character:FindFirstChild("HumanoidRootPart")

    if not humanoid or not rootPart then return end
    
    local currentPosition = rootPart.Position

    -- We determine a "safe" position as any time the player is on the ground.
    -- This prevents saving a position while the player is already falling.
    if humanoid.FloorMaterial ~= Enum.Material.Air then
        Modules.AntiVoid.State.LastSafePosition = currentPosition
    end

    -- Check if the player has fallen below the void threshold
    if currentPosition.Y < Modules.AntiVoid.State.VoidThreshold then
        -- If we have a safe position to return to, teleport the player.
        if Modules.AntiVoid.State.LastSafePosition then
            rootPart.CFrame = CFrame.new(Modules.AntiVoid.State.LastSafePosition)
        end
    end
end

--// Command Registration
RegisterCommand({
    Name = "antivoid",
    Aliases = {"novoid", "av"},
    Description = "Toggles an anti-void system that saves you from falling out of the map."
}, function(args)
    -- Toggle the state
    Modules.AntiVoid.State.Enabled = not Modules.AntiVoid.State.Enabled

    if Modules.AntiVoid.State.Enabled then
        print("Anti-Void: [Enabled]")
        -- Connect the check function to Heartbeat, which runs every frame after the physics simulation.
        Modules.AntiVoid.State.Connection = RunService.Heartbeat:Connect(function()
            Modules.AntiVoid:CheckVoid()
        end)
    else
        print("Anti-Void: [Disabled]")
        -- Disconnect the event when disabled to ensure no resources are used.
        if Modules.AntiVoid.State.Connection then
            Modules.AntiVoid.State.Connection:Disconnect()
            Modules.AntiVoid.State.Connection = nil
            Modules.AntiVoid.State.LastSafePosition = nil -- Clear last saved position
        end
    end
end)

--==========================================================
-- Spoof Owner ID Module
-- Description: Spoofs the game.CreatorId on the client to bypass local checks.
--==========================================================

--// Services
local Players = game:GetService("Players")

--// Module Definition
Modules.SpoofOwnerId = {
    State = {
        -- Store the original CreatorId as soon as the script loads to ensure we can always revert.
        OriginalCreatorId = game.CreatorId,
        IsSpoofed = false
    }
}

--// Helper function to find a player by a partial name (case-insensitive)
local function findFirstPlayer(partialName)
    local lowerPartialName = string.lower(partialName)
    for _, player in ipairs(Players:GetPlayers()) do
        if string.lower(player.Name):sub(1, #lowerPartialName) == lowerPartialName then
            return player
        end
    end
    return nil
end

--// Command Registration
RegisterCommand({
    Name = "spoofownerid",
    Aliases = {"spoofowner", "soid"},
    Description = "Spoofs the game's owner ID locally. Usage: spoofownerid <PlayerName/UserId> | clear"
}, function(args)
    local argument = args[1]

    -- Check if the user wants to clear the spoof
    if not argument then
        print("Usage: spoofownerid <PlayerName/UserId> | clear")
        return
    end

    if string.lower(argument) == "clear" or string.lower(argument) == "reset" then
        if not Modules.SpoofOwnerId.State.IsSpoofed then
            print("Owner ID is not currently spoofed.")
            return
        end
        
        -- Revert to the original CreatorId
        game.CreatorId = Modules.SpoofOwnerId.State.OriginalCreatorId
        Modules.SpoofOwnerId.State.IsSpoofed = false
        print("Owner ID has been reverted to the original: " .. game.CreatorId)
        return
    end

    -- If already spoofing, instruct the user to clear it first
    if Modules.SpoofOwnerId.State.IsSpoofed then
        print("An owner ID is already being spoofed. Use 'spoofownerid clear' to reset it first.")
        return
    end

    local targetId = nil
    
    -- Check if the argument is a number (UserId)
    local isUserId = tonumber(argument)
    if isUserId then
        targetId = isUserId
    else
        -- If not a number, assume it's a player name
        local targetPlayer = findFirstPlayer(argument)
        if targetPlayer then
            targetId = targetPlayer.UserId
        else
            print("Error: Player '" .. argument .. "' not found.")
            return
        end
    end

    -- Perform the spoof
    if targetId then
        game.CreatorId = targetId
        Modules.SpoofOwnerId.State.IsSpoofed = true
        print("Successfully spoofed game Owner ID to: " .. targetId)
    else
        print("Error: Could not determine a valid target ID.")
    end
end)

--==========================================================
-- Fire Interactables Module
-- Description: Fires all ProximityPrompts and TouchEvents within a given radius.
-- Architect: Hailey Marvola
--==========================================================

--// Services (Defined once for efficiency)
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local ProximityPromptService = game:GetService("ProximityPromptService")

--// Module Definition
Modules.FireInteractables = {
    State = {} -- No persistent state needed for this command.
}

--// Command Registration
RegisterCommand({
    Name = "fireall",
    Aliases = {"triggerall", "fa"},
    Description = "Fires all ProximityPrompts and TouchEvents in a radius. Usage: fireall <radius>"
}, function(args)
    --// Character and Position Setup
    local localPlayer = Players.LocalPlayer
    local character = localPlayer and localPlayer.Character
    local rootPart = character and character:FindFirstChild("HumanoidRootPart")

    if not rootPart then
        print("Error: Could not find HumanoidRootPart. Is your character loaded?")
        return
    end

    --// Argument Parsing
    local radius = tonumber(args[1]) or 25 -- Default to 25 studs if no radius is given
    local playerPosition = rootPart.Position

    --// Counters for Summary
    local touchCount = 0
    local promptCount = 0

    print(string.format("Searching for interactables within a %d stud radius...", radius))

    --// Main Execution Loop
    for _, descendant in ipairs(Workspace:GetDescendants()) do
        -- Wrapped in a pcall to prevent errors on restricted/internal objects
        local success, err = pcall(function()
            -- 1. Handle ProximityPrompts
            if descendant:IsA("ProximityPrompt") and descendant.Enabled then
                local part = descendant.Parent
                if part and part:IsA("BasePart") then
                    if (part.Position - playerPosition).Magnitude <= radius then
                        -- Use the correct client-side function to trigger a prompt
                        ProximityPromptService:InputTriggered(descendant)
                        promptCount = promptCount + 1
                    end
                end
            
            -- 2. Handle TouchEvents on BaseParts
            elseif descendant:IsA("BasePart") then
                if (descendant.Position - playerPosition).Magnitude <= radius then
                    -- Ensure the part is not part of our own character
                    if not descendant:IsDescendantOf(character) then
                        -- Fire the Touched event, which will replicate to the server
                        descendant.Touched:Fire(rootPart)
                        touchCount = touchCount + 1
                    end
                end
            end
        end)

        if not success then
            warn("FireInteractables Warning: Could not process an object. Details: " .. err)
        end
    end

    --// Final Summary Report
    print(string.format("Execution complete. Triggered: %d ProximityPrompts and fired %d TouchEvents.", promptCount, touchCount))
    print("Note: ClickDetectors cannot be fired from a LocalScript and were ignored.")
end)


--==========================================================
-- Server Hop Module
-- Description: Finds and teleports the player to a different public server in the same game.
--==========================================================

--// Services
local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")

--// Module Definition
Modules.ServerHop = {
    State = {} -- No state needs to be stored for this command.
}

--// Command Registration
RegisterCommand({
    Name = "serverhop",
    Aliases = {"hop", "sh"},
    Description = "Finds a new server and teleports you to it."
}, function(args)
    local localPlayer = Players.LocalPlayer
    local currentPlaceId = game.PlaceId
    local currentJobId = game.JobId

    print("Fetching server list, please wait...")

    -- Construct the API endpoint URL
    local requestUrl = string.format("https://games.roblox.com/v1/games/%d/servers/Public?sortOrder=Asc&limit=100", currentPlaceId)

    local success, response = pcall(function()
        return HttpService:GetAsync(requestUrl)
    end)

    if not success then
        print("Server Hop Error: Could not fetch the server list. The API may be down or unreachable.")
        return
    end

    local decodedResponse = HttpService:JSONDecode(response)
    local serverList = decodedResponse and decodedResponse.data

    if not serverList or #serverList == 0 then
        print("Server Hop Error: No other servers were found.")
        return
    end

    -- Filter the list to find valid servers to hop to
    local validServers = {}
    for _, server in ipairs(serverList) do
        -- A valid server is one that is not our current server and is not full.
        if server.id ~= currentJobId and server.playing < server.maxPlayers then
            table.insert(validServers, server)
        end
    end

    if #validServers == 0 then
        print("Server Hop: No other non-full servers are available right now.")
        return
    end

    -- Select a random server from our valid list
    local targetServer = validServers[math.random(1, #validServers)]
    print(string.format("Found %d valid servers. Hopping to server with %d/%d players.", #validServers, targetServer.playing, targetServer.maxPlayers))

    -- Teleport to the chosen server instance
    local teleportSuccess, teleportError = pcall(function()
        TeleportService:TeleportToPlaceInstance(currentPlaceId, targetServer.id, localPlayer)
    end)

    if not teleportSuccess then
        print("Server Hop failed: " .. teleportError)
    end
end)

--==========================================================
-- Rejoin Server Module
-- Description: Allows the player to rejoin the current server.
--==========================================================

--// Services
local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")

--// Module Definition
Modules.RejoinServer = {
    State = {} -- No state needs to be stored for this command.
}

--// Command Registration
RegisterCommand({
    Name = "rejoin",
    Aliases = {"rj", "reconnect"},
    Description = "Teleports you back to the current server."
}, function(args)
    local localPlayer = Players.LocalPlayer
    
    if not localPlayer then
        print("Error: Could not find LocalPlayer.")
        return
    end

    local placeId = game.PlaceId
    local jobId = game.JobId

    print("Rejoining server... Please wait.")

    -- Use TeleportToPlaceInstance to join a specific server ID (JobId)
    local success, errorMessage = pcall(function()
        TeleportService:TeleportToPlaceInstance(placeId, jobId, localPlayer)
    end)

    if not success then
        print("Rejoin failed: " .. errorMessage)
    end
end)

--==========================================================
-- Bypass Chat Filter Module
-- Description: Intercepts and modifies chat messages to bypass the filter using Unicode characters.
--==========================================================

--// Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")

--// Module Definition
Modules.BypassChatFilter = {
    State = {
        Enabled = false,
        ChatRemote = nil,
        OriginalNamecall = nil
    },
    -- This map contains standard characters and their Unicode replacements.
    BypassFont = {
        ['a'] = '', ['b'] = '', ['c'] = '', ['d'] = '', ['e'] = '',
        ['f'] = 'f', ['g'] = '', ['h'] = '', ['i'] = '', ['j'] = '',
        ['k'] = 'k', ['l'] = 'l', ['m'] = 'm', ['n'] = 'n', ['o'] = '',
        ['p'] = '', ['q'] = '', ['r'] = '', ['s'] = '', ['t'] = 't',
        ['u'] = 'u', ['v'] = 'v', ['w'] = 'w', ['x'] = '', ['y'] = '',
        ['z'] = 'z',
        ['A'] = '', ['B'] = '', ['C'] = '', ['D'] = '', ['E'] = '',
        ['F'] = 'F', ['G'] = 'G', ['H'] = '', ['I'] = '', ['J'] = '',
        ['K'] = 'K', ['L'] = 'L', ['M'] = '', ['N'] = 'N', ['O'] = '',
        ['P'] = '', ['Q'] = '', ['R'] = 'R', ['S'] = '', ['T'] = '',
        ['U'] = 'U', ['V'] = 'V', ['W'] = 'W', ['X'] = '', ['Y'] = '',
        ['Z'] = 'Z'
    }
}

--// Core Logic
-- This function takes a string and converts it to its bypassed equivalent.
function Modules.BypassChatFilter:ConvertToBypass(text)
    local bypassedText = ""
    for i = 1, #text do
        local char = text:sub(i, i)
        -- If the character exists in our font map, use the replacement. Otherwise, use the original character.
        bypassedText = bypassedText .. (self.BypassFont[char] or char)
    end
    return bypassedText
end

--// Command Registration
RegisterCommand({
    Name = "bypasschatfilter",
    Aliases = {"bcf", "chatbypass"},
    Description = "Toggles a chat filter bypass by replacing characters with Unicode equivalents."
}, function(args)
    -- Toggle the state
    Modules.BypassChatFilter.State.Enabled = not Modules.BypassChatFilter.State.Enabled

    if Modules.BypassChatFilter.State.Enabled then
        -- Find the chat remote. This path is standard for many games.
        local success, chatRemote = pcall(function()
            return ReplicatedStorage:WaitForChild("DefaultChatSystemChatEvents"):WaitForChild("SayMessageRequest")
        end)

        if not success then
            print("Chat Bypass Error: Could not find the standard chat RemoteEvent. This game may use a custom chat system.")
            Modules.BypassChatFilter.State.Enabled = false -- Revert toggle
            return
        end

        Modules.BypassChatFilter.State.ChatRemote = chatRemote
        
        -- The core of the bypass: Hooking the __namecall metamethod
        local mt = getrawmetatable(chatRemote)
        Modules.BypassChatFilter.State.OriginalNamecall = mt.__namecall

        mt.__namecall = newcclosure(function(self, ...)
            local method = getnamecallmethod()
            local args = {...}

            -- We only intercept the 'FireServer' call.
            if method == "FireServer" and #args > 0 then
                -- The first argument is the message text. We convert it.
                args[1] = Modules.BypassChatFilter:ConvertToBypass(args[1])
                print("Bypassed message: " .. args[1])
            end

            -- Call the original function with the (potentially modified) arguments.
            return Modules.BypassChatFilter.State.OriginalNamecall(self, table.unpack(args))
        end)
        
        print("Chat Filter Bypass: [Enabled]")
    else
        -- Restore the original functionality
        if Modules.BypassChatFilter.State.ChatRemote and Modules.BypassChatFilter.State.OriginalNamecall then
            local mt = getrawmetatable(Modules.BypassChatFilter.State.ChatRemote)
            mt.__namecall = Modules.BypassChatFilter.State.OriginalNamecall
            
            -- Clear state variables
            Modules.BypassChatFilter.State.ChatRemote = nil
            Modules.BypassChatFilter.State.OriginalNamecall = nil
            
            print("Chat Filter Bypass: [Disabled]")
        else
            print("Chat Filter Bypass: Was not active or already disabled.")
        end
    end
end)

--==========================================================
-- Anti-Fling Module
-- Description: Prevents the local player from being flung by clamping excessive velocity.
--==========================================================

--// Services
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

--// Module Definition
Modules.AntiFling = {
    State = {
        Enabled = false,
        Connection = nil,
        MaxVelocity = 200 -- Studs/second. A safe threshold to prevent flinging but allow normal movement.
    }
}

--// Core Logic
function Modules.AntiFling:CheckVelocity()
    local localPlayer = Players.LocalPlayer
    local character = localPlayer and localPlayer.Character
    local rootPart = character and character:FindFirstChild("HumanoidRootPart")

    if not rootPart then return end

    -- Check linear velocity (movement speed)
    if rootPart.AssemblyLinearVelocity.Magnitude > Modules.AntiFling.State.MaxVelocity then
        rootPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
    end

    -- Check angular velocity (spin speed)
    if rootPart.AssemblyAngularVelocity.Magnitude > Modules.AntiFling.State.MaxVelocity then
        rootPart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
    end
end

--// Command Registration
RegisterCommand({
    Name = "antifling",
    Aliases = {"nofling", "af"},
    Description = "Toggles an anti-fling system to prevent high-velocity character flinging."
}, function(args)
    -- Toggle the state
    Modules.AntiFling.State.Enabled = not Modules.AntiFling.State.Enabled

    if Modules.AntiFling.State.Enabled then
        -- If enabled, create the connection to the physics step
        print("Anti-Fling: [Enabled]")
        Modules.AntiFling.State.Connection = RunService.Heartbeat:Connect(function()
            Modules.AntiFling:CheckVelocity()
        end)
    else
        -- If disabled, disconnect the event to save performance
        print("Anti-Fling: [Disabled]")
        if Modules.AntiFling.State.Connection then
            Modules.AntiFling.State.Connection:Disconnect()
            Modules.AntiFling.State.Connection = nil
        end
    end
end)

--==========================================================
-- Humanoid Properties Editor Module
-- Description: Creates a UI to edit the local player's Humanoid properties in real-time.
--==========================================================

--// Services
local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer

--// Module Definition
Modules.EditStats = {
    State = {
        UI = nil -- This will hold the ScreenGui once it's created.
    }
}

--// Core Logic - This function creates the entire UI from scratch.
function Modules.EditStats:CreateUI()
    -- If the UI already exists, don't do anything.
    if self.State.UI then return end

    --// --- GUI INSTANCES ---
    -- The main ScreenGui container
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "HumanoidEditor"
    screenGui.ResetOnSpawn = false -- Crucial for persistence across respawns
    screenGui.Parent = localPlayer:WaitForChild("PlayerGui")
    self.State.UI = screenGui

    -- The main draggable frame
    local mainFrame = Instance.new("Frame")
    mainFrame.Name = "MainFrame"
    mainFrame.Size = UDim2.new(0, 250, 0, 300)
    mainFrame.Position = UDim2.new(0.5, -125, 0.5, -150)
    mainFrame.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
    mainFrame.BorderSizePixel = 1
    mainFrame.BorderColor3 = Color3.fromRGB(120, 120, 120)
    mainFrame.Active = true
    mainFrame.Draggable = true
    mainFrame.Parent = screenGui

    -- Title bar
    local titleLabel = Instance.new("TextLabel")
    titleLabel.Name = "Title"
    titleLabel.Size = UDim2.new(1, 0, 0, 30)
    titleLabel.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    titleLabel.Text = "Humanoid Editor"
    titleLabel.Font = Enum.Font.Code
    titleLabel.TextSize = 16
    titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    titleLabel.Parent = mainFrame

    -- Close button
    local closeButton = Instance.new("TextButton")
    closeButton.Name = "CloseButton"
    closeButton.Size = UDim2.new(0, 30, 0, 30)
    closeButton.Position = UDim2.new(1, -30, 0, 0)
    closeButton.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    closeButton.Text = "X"
    closeButton.Font = Enum.Font.Code
    closeButton.TextSize = 16
    closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    closeButton.Parent = titleLabel
    closeButton.MouseButton1Click:Connect(function()
        screenGui.Enabled = false
    end)

    -- Scrolling frame for properties
    local propertyList = Instance.new("ScrollingFrame")
    propertyList.Name = "PropertyList"
    propertyList.Size = UDim2.new(1, 0, 1, -30)
    propertyList.Position = UDim2.new(0, 0, 0, 30)
    propertyList.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    propertyList.CanvasSize = UDim2.new(0, 0, 2, 0) -- Will be auto-sized
    propertyList.Parent = mainFrame
    
    local listLayout = Instance.new("UIListLayout", propertyList)
    listLayout.Padding = UDim.new(0, 5)
    listLayout.SortOrder = Enum.SortOrder.LayoutOrder

    --// --- UI POPULATION & LOGIC ---
    local function populateProperties()
        local character = localPlayer.Character
        local humanoid = character and character:FindFirstChildOfClass("Humanoid")
        if not humanoid then return end
        
        -- Clear any old property frames
        for _, child in ipairs(propertyList:GetChildren()) do
            if child:IsA("Frame") then child:Destroy() end
        end

        local propertiesToEdit = { "WalkSpeed", "JumpPower", "JumpHeight", "HipHeight", "MaxHealth", "Health" }

        for i, propName in ipairs(propertiesToEdit) do
            local propFrame = Instance.new("Frame")
            propFrame.Name = propName .. "Frame"
            propFrame.Size = UDim2.new(1, -10, 0, 30)
            propFrame.Position = UDim2.new(0, 5, 0, 0)
            propFrame.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
            propFrame.LayoutOrder = i
            propFrame.Parent = propertyList

            local nameLabel = Instance.new("TextLabel", propFrame)
            nameLabel.Size = UDim2.new(0.5, 0, 1, 0)
            nameLabel.Text = propName
            nameLabel.Font = Enum.Font.Code
            nameLabel.TextSize = 14
            nameLabel.TextColor3 = Color3.fromRGB(220, 220, 220)
            nameLabel.TextXAlignment = Enum.TextXAlignment.Left
            
            local valueBox = Instance.new("TextBox", propFrame)
            valueBox.Size = UDim2.new(0.5, 0, 1, 0)
            valueBox.Position = UDim2.new(0.5, 0, 0, 0)
            valueBox.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
            valueBox.Font = Enum.Font.Code
            valueBox.TextSize = 14
            valueBox.TextColor3 = Color3.fromRGB(255, 255, 255)
            valueBox.Text = tostring(humanoid[propName])

            -- The update logic
            valueBox.FocusLost:Connect(function(enterPressed)
                if enterPressed then
                    local newValue = tonumber(valueBox.Text)
                    local currentHumanoid = localPlayer.Character and localPlayer.Character:FindFirstChildOfClass("Humanoid")
                    
                    if newValue and currentHumanoid then
                        currentHumanoid[propName] = newValue
                        print(string.format("Set %s to %s", propName, newValue))
                        -- Update text again to reflect the actual value (in case of engine clamping)
                        valueBox.Text = tostring(currentHumanoid[propName])
                    else
                        -- Revert text if input was invalid
                        valueBox.Text = tostring(currentHumanoid and currentHumanoid[propName] or "N/A")
                    end
                end
            end)
        end
    end
    
    -- Populate for the first time and set up auto-repopulation on respawn
    if localPlayer.Character then populateProperties() end
    localPlayer.CharacterAdded:Connect(function()
        task.wait(0.5) -- Wait for humanoid to be created
        populateProperties()
    end)
end

--// --- COMMAND REGISTRATION ---
RegisterCommand({
    Name = "editstats",
    Aliases = {"stats", "humanoideditor", "prop"},
    Description = "Opens a properties window to edit your character's Humanoid stats."
}, function(args)
    -- Create the UI if it's the first time running the command.
    Modules.EditStats:CreateUI()
    
    -- Toggle its visibility.
    local ui = Modules.EditStats.State.UI
    ui.Enabled = not ui.Enabled
    print("Humanoid Properties window " .. (ui.Enabled and "shown." or "hidden."))
end)

--==========================================================
-- Bypass Anti-AFK Module
-- Description: Prevents the game from kicking you for being idle by simulating input.
--==========================================================

--// Services
local RunService = game:GetService("RunService")
local VirtualInputManager = game:GetService("VirtualInputManager")

--// Module Definition
Modules.BypassAntiAFK = {
    State = {
        Enabled = false,
        Connection = nil,
        TickCounter = 0,
        Interval = 60 -- Seconds between each simulated input
    }
}

--// Core Logic
function Modules.BypassAntiAFK:SimulateInput()
    -- This function runs every frame, but we only act once the interval is reached.
    self.State.TickCounter = self.State.TickCounter + RunService.Heartbeat:Wait()

    if self.State.TickCounter >= self.State.Interval then
        self.State.TickCounter = 0 -- Reset the counter
        
        -- Simulate a tiny, imperceptible camera pan. This is enough to reset most AFK timers.
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.RightArrow, false, game)
        task.wait(0.05)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.RightArrow, false, game)
        
        print("Anti-AFK Bypass: Simulated input to remain active.")
    end
end

--// Command Registration
RegisterCommand({
    Name = "bypassantiafk",
    Aliases = {"antiafk", "bafk"},
    Description = "Toggles a bypass to prevent being kicked for being idle."
}, function(args)
    -- Toggle the state
    Modules.BypassAntiAFK.State.Enabled = not Modules.BypassAntiAFK.State.Enabled

    if Modules.BypassAntiAFK.State.Enabled then
        print("Anti-AFK Bypass: [Enabled]")
        Modules.BypassAntiAFK.State.Connection = RunService.Heartbeat:Connect(function()
            Modules.BypassAntiAFK:SimulateInput()
        end)
    else
        print("Anti-AFK Bypass: [Disabled]")
        if Modules.BypassAntiAFK.State.Connection then
            Modules.BypassAntiAFK.State.Connection:Disconnect()
            Modules.BypassAntiAFK.State.Connection = nil
        end
        Modules.BypassAntiAFK.State.TickCounter = 0
    end
end)

RegisterCommand({
    Name = "fixcam",
    Aliases = {"fix", "unlockcam"},
    Description = "Unlocks camera, allows zooming through walls, and forces third-person."
}, function(args)
    --// --- Services ---
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local RunService = game:GetService("RunService")

    if not LocalPlayer then return end

    if isCameraFixed and cameraFixConnection and cameraFixConnection.Connected then
        --// --- DISABLING THE FIX ---
        
        cameraFixConnection:Disconnect()
        cameraFixConnection = nil
        
        -- Restore original settings (Safely)
        pcall(function()
            if originalOcclusionMode and originalOcclusionMode ~= nil then
                LocalPlayer.DevCameraOcclusionMode = originalOcclusionMode
            end
            if originalMaxZoom and originalMaxZoom ~= nil then
                LocalPlayer.CameraMaxZoomDistance = originalMaxZoom
            end
        end)
        
        isCameraFixed = false
        DoNotif("Camera override disabled.", 3)
    else
        --// --- ENABLING THE FIX ---
        
        -- 1. Store original values (Crucial for proper cleanup)
        originalMaxZoom = LocalPlayer.CameraMaxZoomDistance
        originalOcclusionMode = LocalPlayer.DevCameraOcclusionMode
        
        -- 2. Set static, persistent properties ONCE
        
        -- Unlock Zoom Distance
        LocalPlayer.CameraMaxZoomDistance = 10000 
        
        -- 3. [CRITICAL FIX] Set DevCameraOcclusionMode with a pcall
        local success, err = pcall(function()
            -- Attempt to use the 'None' enum member
            LocalPlayer.DevCameraOcclusionMode = Enum.DevCameraOcclusionMode.None
        end)

        if not success then
            -- Fallback 1: Try setting it to its numeric ID (None is often 0)
            -- This works in some restricted environments where the enum name fails but the value is allowed.
            LocalPlayer.DevCameraOcclusionMode = 0 
            
            -- Optional: Log the failure to diagnose why it broke
            warn("Failed to set DevCameraOcclusionMode to Enum.None. Falling back to numeric value 0. Error: " .. tostring(err))
        end
        
        -- 4. Use RenderStepped ONLY to fight CameraMode overrides
        cameraFixConnection = RunService.RenderStepped:Connect(function()
            -- Force Third-Person (Only check/set the value if it's not the desired value)
            if LocalPlayer.CameraMode ~= Enum.CameraMode.Classic then
                LocalPlayer.CameraMode = Enum.CameraMode.Classic
            end
        end)
        
        isCameraFixed = true
        DoNotif("Camera override enabled (with wall-zoom).", 3)
    end
end)

RegisterCommand({Name = "cmds", Aliases = {"help"}, Description = "Shows this command list."}, function() Modules.CommandsUI:Toggle() end)
RegisterCommand({Name = "cmdbar", Aliases = {"cbar"}, Description = "Toggles the private command bar."}, function() Modules.CommandBar:Toggle() end)
RegisterCommand({Name = "ide", Aliases = {}, Description = "Opens a script execution window."}, function() Modules.IDE:Toggle() end)
RegisterCommand({Name = "decompile", Aliases = {"decomp", "disassemble"}, Description = "Initializes the Konstant decompiler functions."}, function() Modules.Decompiler:Initialize() end)

-- Player Modification Commands
RegisterCommand({Name = "fly", Aliases = {}, Description = "Toggles smooth flight mode."}, function() Modules.Fly:Toggle() end)
RegisterCommand({Name = "flyspeed", Aliases = {}, Description = "Sets fly speed. ;flyspeed [num]"}, function(args) Modules.Fly:SetSpeed(args[1]) end)
RegisterCommand({Name = "speed", Aliases = {}, Description = "Sets walkspeed. ;speed [num]"}, function(args) local s=tonumber(args[1]); local h=LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid"); if not h then DoNotif("Humanoid not found!", 3) return end; if s and s > 0 then h.WalkSpeed = s; DoNotif("WalkSpeed set to: " .. s, 3) else DoNotif("Invalid speed.", 3) end end)
RegisterCommand({Name = "noclip", Aliases = {}, Description = "Toggles walking through walls."}, function() Modules.Noclip:Toggle() end)
RegisterCommand({Name = "wallwalk", Aliases = {"ww"}, Description = "Toggles walking on walls."}, function() Modules.WallWalk:Toggle() end)
RegisterCommand({Name = "godmode", Aliases = {"god"}, Description = "Toggles invincibility. Use ;god [method|off] or ;god for a menu."}, function(args) Modules.Godmode:HandleCommand(args) end)
RegisterCommand({Name = "ungodmode", Aliases = {"ungod"}, Description = "Disables invincibility."}, function() Modules.Godmode:Disable() end)
RegisterCommand({Name = "goto", Aliases = {}, Description = "Teleports to a player. ;goto [player]"}, function(args)
RegisterCommand({Name = "antikb", Aliases = {"akb"}, Description = "Toggles client-side anti-kill-brick (health lock)."}, function() Modules.AntiKB:Toggle() end)

    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer

    --// --- Argument Validation ---
    local inputName = args[1] and tostring(args[1]):lower()
    if not inputName or inputName == "" then
        return DoNotif("Specify a player's name.", 3)
    end

    --// --- Find Target Player (with DisplayName support) ---
    local exactMatch = nil
    local partialMatch = nil

    -- Loop through all players to find the best possible match
    for _, player in ipairs(Players:GetPlayers()) do
        local username = player.Name:lower()
        local displayName = player.DisplayName:lower()

        -- Priority 1: Check for an exact match (username or display name)
        if username == inputName or displayName == inputName then
            exactMatch = player
            break -- Found the best possible match, no need to search further
        end

        -- Priority 2: If no partial match has been found yet, check for one
        if not partialMatch then
            if username:sub(1, #inputName) == inputName or displayName:sub(1, #inputName) == inputName then
                partialMatch = player -- Store the first partial match we find
            end
        end
    end

    -- Decide the final target based on priority (exact is better than partial)
    local targetPlayer = exactMatch or partialMatch

    --// --- Execution ---
    if targetPlayer then
        local localHRP = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        local targetHRP = targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart")

        if localHRP and targetHRP then
            -- Teleport to the target's position, slightly elevated
            localHRP.CFrame = targetHRP.CFrame + Vector3.new(0, 3, 0)
            -- Use the actual username in the notification for clarity
            DoNotif("Teleported to " .. targetPlayer.Name, 3)
        else
            DoNotif("Target player's character could not be found.", 3)
        end
    else
        DoNotif("Player not found.", 3)
    end
end)

RegisterCommand({
    Name = "fireclick",
    Aliases = {"fclick", "click"},
    Description = "Fires a ClickDetector on the part under your mouse. Use 'all' to fire every ClickDetector in a 50 stud radius."
}, function(args)
    --// --- Services & Local Player ---
    local Players = game:GetService("Players")
    local Workspace = game:GetService("Workspace")
    local UserInputService = game:GetService("UserInputService")
    local LocalPlayer = Players.LocalPlayer

    --// --- Check for "all" argument ---
    if args[1] and args[1]:lower() == "all" then
        --// --- FIRE ALL IN RADIUS LOGIC ---
        local character = LocalPlayer.Character
        local hrp = character and character:FindFirstChild("HumanoidRootPart")
        if not hrp then
            return DoNotif("Your character could not be found.", 3)
        end

        local RADIUS = 50
        local partsInRadius = Workspace:GetPartBoundsInRadius(hrp.Position, RADIUS)
        local fireCount = 0

        for _, part in ipairs(partsInRadius) do
            local clickDetector = part:FindFirstChildOfClass("ClickDetector")
            if clickDetector then
                fireclickdetector(part, 0)
                fireCount = fireCount + 1
            end
        end
        DoNotif("Fired " .. fireCount .. " ClickDetectors within " .. RADIUS .. " studs.", 4)
    else
        --// --- ORIGINAL MOUSE TARGET LOGIC ---
        local mouseLocation = UserInputService:GetMouseLocation()
        local camera = Workspace.CurrentCamera
        local mouseRay = camera:ScreenPointToRay(mouseLocation.X, mouseLocation.Y)
        
        local raycastParams = RaycastParams.new()
        raycastParams.FilterType = Enum.RaycastFilterType.Exclude
        raycastParams.FilterDescendantsInstances = {LocalPlayer.Character}
        
        local raycastResult = Workspace:Raycast(mouseRay.Origin, mouseRay.Direction * 1000, raycastParams)
        local targetPart = raycastResult and raycastResult.Instance

        if not targetPart then
            return DoNotif("No target part found under the mouse.", 3)
        end

        local clickDetector = targetPart:FindFirstChildOfClass("ClickDetector")
        if clickDetector then
            fireclickdetector(targetPart, 0)
            DoNotif("Fired ClickDetector on: " .. targetPart.Name, 3)
        else
            DoNotif("No ClickDetector found on the target part.", 3)
        end
    end
end)

RegisterCommand({
    Name = "firetouch",
    Aliases = {"ftouch", "touch"},
    Description = "Fires a Touched event on the part under your mouse. Use 'all' to touch every part in a 50 stud radius."
}, function(args)
    --// --- Services & Local Player ---
    local Players = game:GetService("Players")
    local Workspace = game:GetService("Workspace")
    local UserInputService = game:GetService("UserInputService")
    local LocalPlayer = Players.LocalPlayer
    local localCharacter = LocalPlayer.Character

    if not localCharacter then return DoNotif("Your character could not be found.", 3) end
    local touchPart = localCharacter:FindFirstChild("HumanoidRootPart")
    if not touchPart then return DoNotif("Your HumanoidRootPart could not be found.", 3) end

    --// --- Check for "all" argument ---
    if args[1] and args[1]:lower() == "all" then
        --// --- FIRE ALL IN RADIUS LOGIC ---
        local RADIUS = 50
        local partsInRadius = Workspace:GetPartBoundsInRadius(touchPart.Position, RADIUS)
        local fireCount = 0

        for _, part in ipairs(partsInRadius) do
            -- Important check: Don't fire touch events on players' character parts
            if not Players:GetPlayerFromCharacter(part:FindFirstAncestorOfClass("Model")) then
                firetouchinterest(touchPart, part, 0)
                firetouchinterest(touchPart, part, 1)
                fireCount = fireCount + 1
            end
        end
        DoNotif("Fired Touched event on " .. fireCount .. " parts within " .. RADIUS .. " studs.", 4)
    else
        --// --- ORIGINAL MOUSE TARGET LOGIC ---
        local mouseLocation = UserInputService:GetMouseLocation()
        local camera = Workspace.CurrentCamera
        local mouseRay = camera:ScreenPointToRay(mouseLocation.X, mouseLocation.Y)
        
        local raycastParams = RaycastParams.new()
        raycastParams.FilterType = Enum.RaycastFilterType.Exclude
        raycastParams.FilterDescendantsInstances = {localCharacter}
        
        local raycastResult = Workspace:Raycast(mouseRay.Origin, mouseRay.Direction * 1000, raycastParams)
        local targetPart = raycastResult and raycastResult.Instance

        if not targetPart then
            return DoNotif("No target part found under the mouse.", 3)
        end

        firetouchinterest(touchPart, targetPart, 0)
        firetouchinterest(touchPart, targetPart, 1)
        DoNotif("Fired Touched event on: " .. targetPart.Name, 3)
    end
end)

-- Combat & Interaction Commands
RegisterCommand({Name = "reach", Aliases = {"swordreach"}, Description = "Extends sword reach. ;reach [num]"}, function(args) Modules.Reach:Apply("directional", tonumber(args[1]) or 15) end)
RegisterCommand({Name = "boxreach", Aliases = {}, Description = "Creates a box hitbox. ;boxreach [num]"}, function(args) Modules.Reach:Apply("box", tonumber(args[1]) or 15) end)
RegisterCommand({Name = "resetreach", Aliases = {"unreach"}, Description = "Resets tool reach to normal."}, function() Modules.Reach:Reset() end)
RegisterCommand({Name = "clickfling", Aliases = {}, Description = "Enables click to fling players."}, function() Modules.ClickFling:Enable() end)
RegisterCommand({Name = "unclickfling", Aliases = {}, Description = "Disables click to fling."}, function() Modules.ClickFling:Disable() end)
RegisterCommand({Name = "clicktp", Aliases = {}, Description = "Hold Left CTRL to teleport to cursor."}, function() Modules.ClickTP:Toggle() end)
RegisterCommand({
    Name = "modelreach",
    Aliases = {"mreach"},
    Description = "Extends tool reach on a specified model. ;mreach [model_name] [size]"
}, function(args)
    local modelName = args[1]
    local size = tonumber(args[2]) or 15
    if not modelName then
        return DoNotif("Please specify a model name.", 3)
    end
    Modules.ModelReach:Apply(modelName, "directional", size)
end)

RegisterCommand({
    Name = "modelboxreach",
    Aliases = {"mboxreach"},
    Description = "Creates a box hitbox on a tool in a model. ;mboxreach [model_name] [size]"
}, function(args)
    local modelName = args[1]
    local size = tonumber(args[2]) or 15
    if not modelName then
        return DoNotif("Please specify a model name.", 3)
    end
    Modules.ModelReach:Apply(modelName, "box", size)
end)

RegisterCommand({
    Name = "resetmodelreach",
    Aliases = {"unmreach"},
    Description = "Resets tool reach on a specified model. ;unmreach [model_name]"
}, function(args)
    local modelName = args[1]
    if not modelName then
        return DoNotif("Please specify a model name.", 3)
    end
    Modules.ModelReach:Reset(modelName)
end)

-- Utility Commands
RegisterCommand({Name = "esp", Aliases = {}, Description = "Toggles player outline, name, and team."}, function() Modules.ESP:Toggle() end)
RegisterCommand({Name = "antikick", Aliases = {"ak"}, Description = "Hooks metamethods to prevent being kicked."}, function() Modules.AntiKick:Toggle() end)
RegisterCommand({Name = "grabtools", Aliases = {}, Description = "Auto-grabs tools that appear."}, function() Modules.GrabTools:Toggle() end)
RegisterCommand({Name = "ibtools", Aliases = {}, Description = "Loads a building helper tool for deleting/modifying parts."}, function() Modules.iBTools:Toggle() end)
RegisterCommand({Name = "selector", Aliases = {"partselector", "ps"}, Description = "Toggles a HUD to identify parts and models under the cursor."}, function() Modules.PartSelector:Toggle() end)
-- Loadstring / External Script Commands
local function loadstringCmd(url, notif) pcall(function() loadstring(game:HttpGet(url))() end); DoNotif(notif, 3) end
RegisterCommand({Name = "zui", Aliases = {}, Description = "Loads the Zombie Hub"}, function() loadstringCmd("https://raw.githubusercontent.com/scriptlisenbe-stack/luaprojectse3/refs/heads/main/ZGUI.txt", "Loading Zombie Hub...") end)
RegisterCommand({Name = "zukahub", Aliases = {"zhub"}, Description = "Loads the Zuka Hub"}, function() loadstringCmd("https://raw.githubusercontent.com/zukatechdevelopment-ux/thingsandstuff/refs/heads/main/ZukaHub.lua", "Loading Zuka's Hub...") end)
RegisterCommand({Name = "cat", Aliases = {"catexec"}, Description = "Loads CatBypasser"}, function() loadstringCmd("https://raw.githubusercontent.com/shadow62x/catbypass/main/upfix", "Loading Chat...") end)
RegisterCommand({Name = "dex", Aliases = {"explorer"}, Description = "Opens the Dark Dex explorer for developers."}, function() loadstringCmd("https://raw.githubusercontent.com/scriptlisenbe-stack/luaprojectse3/refs/heads/main/CustomDex.lua", "Loading Dex++") end)
RegisterCommand({Name = "pentest", Aliases = {"ptest"}, Description = "Opens a versatile Remote View GUI."}, function() loadstringCmd("https://raw.githubusercontent.com/scriptlisenbe-stack/luaprojectse3/refs/heads/main/RemoteEvent_Pentester_OP.txt", "Loading Script Hub...") end)
RegisterCommand({Name = "teleportgui", Aliases = {"tpui", "uviewer"}, Description = "Opens a GUI to teleport to other game places."}, function() loadstringCmd("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/main/Universe%20Viewer", "Loading Teleport GUI...") end)
RegisterCommand({Name = "aimbot", Aliases = {"aim"}, Description = "Loads an aimbot script."}, function() loadstringCmd("https://raw.githubusercontent.com/zukatechdevelopment-ux/thingsandstuff/refs/heads/main/ZukasAimbot.lua", "Loading Aimbot...") end)
RegisterCommand({Name = "ghost", Aliases = {"invis"}, Description = "OP Works on some games.."}, function() loadstringCmd("https://raw.githubusercontent.com/legalize8ga-maker/PublicReleaseLua/refs/heads/main/soulform.lua", "Loading Invis Mode Use G and H for toggle...") end)
RegisterCommand({Name = "flyr15", Aliases = {"pfly"}, Description = "Loads a specific R15 flight script."}, function() loadstringCmd("https://raw.githubusercontent.com/396abc/Script/refs/heads/main/FlyR15.lua", "Loading R15 Fly...") end)
RegisterCommand({Name = "playerfarm", Aliases = {"pfarm"}, Description = "Loads a GUI addon for farming players."}, function() loadstringCmd("https://raw.githubusercontent.com/zukatechdevelopment-ux/thingsandstuff/refs/heads/main/ragebot.lua", "Loading Farming Addon...") end)
RegisterCommand({Name = "bloxfruits", Aliases = {"bfruit"}, Description = "Loads the one piece script hub."}, function() loadstringCmd("https://raw.githubusercontent.com/AhmadV99/Speed-Hub-X/main/Speed%20Hub%20X.lua", "Loading s0ulzV4...") end)
RegisterCommand({Name = "rspy", Aliases = {"spy"}, Description = "Remote Functions"}, function() loadstringCmd("https://raw.githubusercontent.com/ltseverydayyou/uuuuuuu/main/simplee%20spyyy%20mobilee", "Loading Invis Mode Use G and H for toggle...") end)

-- Aura Command Integration (Adapted)
local auraConn, auraViz
RegisterCommand({Name = "aura", Aliases = {}, Description = "Continuously damages nearby players. ;aura [distance]"}, function(args)
	local dist=tonumber(args[1]) or 20
	if not firetouchinterest then return DoNotif("firetouchinterest unsupported",2) end
	if auraConn then auraConn:Disconnect() end; if auraViz then auraViz:Destroy() end
	auraViz=Instance.new("Part", workspace); auraViz.Shape=Enum.PartType.Ball; auraViz.Size=Vector3.new(dist*2,dist*2,dist*2)
	auraViz.Transparency=0.8; auraViz.Color=Color3.fromRGB(255,0,0); auraViz.Material=Enum.Material.Neon
	auraViz.Anchored=true; auraViz.CanCollide=false
	local function getHandle() local c=LocalPlayer.Character; if not c then return end; local t=c:FindFirstChildWhichIsA("Tool"); if not t then return end; return t:FindFirstChild("Handle") or t:FindFirstChildWhichIsA("BasePart") end
	auraConn=RunService.RenderStepped:Connect(function()
		local handle, root = getHandle(), LocalPlayer.Character and LocalPlayer.Character.HumanoidRootPart
		if not handle or not root then return end
		auraViz.CFrame=root.CFrame
		for _,plr in ipairs(Players:GetPlayers()) do
			if plr~=LocalPlayer and plr.Character then
				local hum=plr.Character:FindFirstChildOfClass("Humanoid")
				if hum and hum.Health>0 then
					for _,part in ipairs(plr.Character:GetChildren()) do
						if part:IsA("BasePart") and (part.Position-handle.Position).Magnitude<=dist then
							firetouchinterest(handle,part,0); task.wait(); firetouchinterest(handle,part,1); break
						end
					end
				end
			end
		end
	end)
	DoNotif("Aura enabled at "..dist,1.2)
end)
RegisterCommand({Name = "unaura", Aliases = {}, Description = "Stops aura loop and removes visualizer."}, function()
	if auraConn then auraConn:Disconnect(); auraConn=nil end
	if auraViz then auraViz:Destroy(); auraViz=nil end
	DoNotif("Aura disabled",1.2)
end)

-- ==========================================================
-- Centralized Command Processor
-- ==========================================================
function processCommand(message)
    -- Check for the prefix at the very beginning of the message
    if not message:sub(1, #Prefix) == Prefix then
        return false -- Return false to indicate it's not a command
    end

    -- Parse the command and its arguments
    local args = {}
    for word in message:sub(#Prefix + 1):gmatch("%S+") do
        table.insert(args, word)
    end

    if #args == 0 then
        return true -- It was a command, but empty. Stop processing.
    end

    local cmdName = table.remove(args, 1):lower()
    local cmdFunc = Commands[cmdName]

    if cmdFunc then
        -- Use pcall to safely execute the command
        local success, err = pcall(cmdFunc, args)
        if not success then
            -- CRITICAL FIX: Report errors instead of failing silently.
            warn("Command Error:", err)
            DoNotif("Error executing '" .. cmdName .. "': " .. tostring(err), 5)
        end
    else
        DoNotif("Unknown command: " .. cmdName, 3)
    end

    return true -- Return true to indicate we handled the command
end

-- ==========================================================
-- Input Handlers
-- ==========================================================
LocalPlayer.Chatted:Connect(processCommand)
Modules.CommandBar:Toggle() -- Start with the command bar open by default

-- MODERN CHAT (TextChatService): Intercepts message before it's sent.
local TextChatService = game:GetService("TextChatService")
if TextChatService then
    TextChatService.Sending:Connect(function(message)
        -- The processCommand function now returns 'true' if it was a command.
        -- If so, we prevent the message from appearing in the public chat.
        if processCommand(message.Text) then
            message.Text = "" -- Clear the message text
            return Enum.TextChatMessageStatus.Success
        end
    end)
    DoNotif("Hooked into modern TextChatService.", 4)
else
    -- LEGACY CHAT (Player.Chatted): Fallback for older games.
    LocalPlayer.Chatted:Connect(processCommand)
    DoNotif("Hooked into legacy Chat system.", 4)
end

DoNotif("Zuka's Admin (Reworked) | Prefix: '" .. Prefix .. "' | ;cmds for help", 6)